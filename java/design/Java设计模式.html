<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.67">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/favicon.ico"><title>Java设计模式 | VuePress ！</title><meta name="description" content="这是我的第一个 VuePress 站点">
    <link rel="preload" href="/vuepress-starter/assets/style-9631a17f.css" as="style"><link rel="stylesheet" href="/vuepress-starter/assets/style-9631a17f.css">
    <link rel="modulepreload" href="/vuepress-starter/assets/app-999de8cb.js"><link rel="modulepreload" href="/vuepress-starter/assets/Java设计模式.html-4585117b.js"><link rel="modulepreload" href="/vuepress-starter/assets/Java设计模式.html-7f13f31c.js"><link rel="prefetch" href="/vuepress-starter/assets/index.html-3e48afd3.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Docker-compose命令大全.html-93eb499d.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Docker常用命令大全.html-f3e287e3.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Docker镜像构建.html-7d7e4c30.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-01-Kubernetes系统原理.html-9dccf374.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-03-Kubeadm搭建集群.html-a0f434da.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-04-Kubectl核心使用.html-b7221f79.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-05-Dashboard安装和使用.html-b4ef007e.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-06-Pod原理和详解.html-af85acb7.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-07-工作负载详情.html-efda3e84.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-08-服务介绍.html-ccd6b91c.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-09-Ingress.html-390ccaf5.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-10-Storage.html-6e04cf17.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-11-集群配置默认存储类.html-b26ea5f4.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-12-Configmap和Secret.html-90e577e4.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-13-HorizontalPodAutoscaler.html-8899a225.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-14-创建并部署WordPress.html-104e8204.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-15-部署中间件.html-47c1520e.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-16-Devops.html-2248dbdf.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-17-Istio基本介绍.html-adf5b5c0.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/字典树.html-e2c6ee6a.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/常用10种算法.html-5b8b9a70.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/排序算法.html-701197dc.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/AQS工具类.html-bca75b08.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Atomic和Unsafe.html-1c37fa28.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/CPU缓存一致性协议MESI.html-f077c1c5.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Collections.html-b8e8c729.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Executor线程池.html-ce612aa5.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Future_ForkJoin.html-fa843369.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Java内存模型.html-1c30a945.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Synchronized.html-ac25c50f.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/抽象队列同步器AQS.html-9d1d4326.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/操作系统底层的整体认识.html-9ac36108.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/JVM内存模型.html-77ac90db.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/JVM对象创建和内存分配.html-4da68e3a.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/JVM类加载机制.html-d5eacc9b.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/垃圾收集器G1和ZGC.html-6331579d.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/垃圾收集器ParNew和CMS.html-270444fe.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/中介者模式.html-adab21e6.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/命令模式.html-1320181f.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/备忘录模式.html-02606526.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/模板模式.html-3e94ee87.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/状态模式.html-a7df6975.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/策略模式.html-3e7ccbc8.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/观察者模式.html-1ce60350.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/解释器模式.html-a12c04bf.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/访问者模式.html-8abb08b5.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/责任链模式.html-aac04461.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/迭代器模式.html-3e4eb5b7.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/单例模式.html-db73cadd.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/原型模式.html-460cbe27.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/工厂模式.html-350ff1b7.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/建造者模式.html-cb877207.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/抽象工厂模式.html-4ae2d885.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/享元模式.html-e45e53dd.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/代理模式.html-8e1b3a0e.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/外观模式.html-a69f5545.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/桥接模式.html-53c942e8.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/组合模式.html-d7b5c1c4.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/装饰器模式.html-4d7645dc.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/适配器模式.html-e84d0f15.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/404.html-f9875e7b.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/index.html-ed3383e4.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Docker-compose命令大全.html-2a0e4dba.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Docker常用命令大全.html-d79b09e2.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Docker镜像构建.html-9df2a948.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-01-Kubernetes系统原理.html-e458650d.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-03-Kubeadm搭建集群.html-725522cd.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-04-Kubectl核心使用.html-9f1e9afa.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-05-Dashboard安装和使用.html-839ddae0.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-06-Pod原理和详解.html-3e166721.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-07-工作负载详情.html-918c6c68.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-08-服务介绍.html-4aad69bb.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-09-Ingress.html-8740ccf8.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-10-Storage.html-c6314a04.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-11-集群配置默认存储类.html-abf0f6d3.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-12-Configmap和Secret.html-3e5046e2.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-13-HorizontalPodAutoscaler.html-7b61da35.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-14-创建并部署WordPress.html-e5acb658.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-15-部署中间件.html-e51d13e7.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-16-Devops.html-c98b659c.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/k8s-17-Istio基本介绍.html-f5e59953.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/字典树.html-2c7285a6.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/常用10种算法.html-17a1c49f.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/排序算法.html-95e4dbce.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/AQS工具类.html-77fb2478.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Atomic和Unsafe.html-06dfb1a4.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/CPU缓存一致性协议MESI.html-dcabccb4.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Collections.html-655c9984.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Executor线程池.html-0b5f0c4a.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Future_ForkJoin.html-c27a14af.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Java内存模型.html-3f3ce9c0.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/Synchronized.html-c7bad751.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/抽象队列同步器AQS.html-54b969ae.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/操作系统底层的整体认识.html-7af80a08.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/JVM内存模型.html-a4e8e02a.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/JVM对象创建和内存分配.html-b3baf044.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/JVM类加载机制.html-47e18e2c.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/垃圾收集器G1和ZGC.html-370e712a.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/垃圾收集器ParNew和CMS.html-0b2a9e5f.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/中介者模式.html-88a3afb3.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/命令模式.html-0bace85b.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/备忘录模式.html-98b5d718.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/模板模式.html-a1a3122a.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/状态模式.html-1d50687c.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/策略模式.html-544dd235.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/观察者模式.html-4b21f482.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/解释器模式.html-cdfb208c.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/访问者模式.html-2b7948bf.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/责任链模式.html-350335a1.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/迭代器模式.html-4f2e1555.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/单例模式.html-4e5f5e21.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/原型模式.html-3a79c02a.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/工厂模式.html-817019fa.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/建造者模式.html-76aa3e09.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/抽象工厂模式.html-f519b0c7.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/享元模式.html-a461053e.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/代理模式.html-7393c115.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/外观模式.html-99ee7d35.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/桥接模式.html-1eaaaca9.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/组合模式.html-d68ec25b.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/装饰器模式.html-dba31b7c.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/适配器模式.html-a07dfe6c.js" as="script"><link rel="prefetch" href="/vuepress-starter/assets/404.html-38d245cb.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/vuepress-starter/" class=""><!----><span class="site-name">VuePress ！</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Java"><span class="title">Java</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Java"><span class="title">Java</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/vuepress-starter/java/jvm/JVM内存模型.md" class="" aria-label="Jvm"><!--[--><!--]--> Jvm <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/vuepress-starter/java/arithmetic/字典树.md" class="" aria-label="数据结构与算法"><!--[--><!--]--> 数据结构与算法 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/vuepress-starter/java/concurrent/操作系统底层的整体认识.md" class="" aria-label="并发编程"><!--[--><!--]--> 并发编程 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><a href="/vuepress-starter/java/design/Java设计模式.md" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress-starter/java/design/build/单例模式.md" class="" aria-label="创建型模式"><!--[--><!--]--> 创建型模式 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress-starter/java/design/structure/享元模式.md" class="" aria-label="结构型模式"><!--[--><!--]--> 结构型模式 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress-starter/java/design/action/中介者模式.md" class="" aria-label="行为型模式"><!--[--><!--]--> 行为型模式 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Devops"><span class="title">Devops</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Devops"><span class="title">Devops</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/vuepress-starter/devops/docker/Docker常用命令大全.md" class="" aria-label="docker"><!--[--><!--]--> docker <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/vuepress-starter/devops/kubernetes/k8s-01-Kubernetes系统原理.md" class="" aria-label="kubernetes"><!--[--><!--]--> kubernetes <!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Java"><span class="title">Java</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Java"><span class="title">Java</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/vuepress-starter/java/jvm/JVM内存模型.md" class="" aria-label="Jvm"><!--[--><!--]--> Jvm <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/vuepress-starter/java/arithmetic/字典树.md" class="" aria-label="数据结构与算法"><!--[--><!--]--> 数据结构与算法 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/vuepress-starter/java/concurrent/操作系统底层的整体认识.md" class="" aria-label="并发编程"><!--[--><!--]--> 并发编程 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><a href="/vuepress-starter/java/design/Java设计模式.md" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vuepress-starter/java/design/build/单例模式.md" class="" aria-label="创建型模式"><!--[--><!--]--> 创建型模式 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress-starter/java/design/structure/享元模式.md" class="" aria-label="结构型模式"><!--[--><!--]--> 结构型模式 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vuepress-starter/java/design/action/中介者模式.md" class="" aria-label="行为型模式"><!--[--><!--]--> 行为型模式 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Devops"><span class="title">Devops</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Devops"><span class="title">Devops</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/vuepress-starter/devops/docker/Docker常用命令大全.md" class="" aria-label="docker"><!--[--><!--]--> docker <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/vuepress-starter/devops/kubernetes/k8s-01-Kubernetes系统原理.md" class="" aria-label="kubernetes"><!--[--><!--]--> kubernetes <!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active">设计模式 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vuepress-starter/java/design/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="Java设计模式"><!--[--><!--]--> Java设计模式 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vuepress-starter/java/design/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#一、什么是设计模式" class="router-link-active router-link-exact-active sidebar-item" aria-label="一、什么是设计模式"><!--[--><!--]--> 一、什么是设计模式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress-starter/java/design/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#二、设计模式的三大分类及关键点" class="router-link-active router-link-exact-active sidebar-item" aria-label="二、设计模式的三大分类及关键点"><!--[--><!--]--> 二、设计模式的三大分类及关键点 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vuepress-starter/java/design/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_1、创建型模式" class="router-link-active router-link-exact-active sidebar-item" aria-label="1、创建型模式"><!--[--><!--]--> 1、创建型模式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress-starter/java/design/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_2、结构型模式" class="router-link-active router-link-exact-active sidebar-item" aria-label="2、结构型模式"><!--[--><!--]--> 2、结构型模式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress-starter/java/design/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_3、行为型模式" class="router-link-active router-link-exact-active sidebar-item" aria-label="3、行为型模式"><!--[--><!--]--> 3、行为型模式 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/vuepress-starter/java/design/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#三、设计模式的几种原则" class="router-link-active router-link-exact-active sidebar-item" aria-label="三、设计模式的几种原则"><!--[--><!--]--> 三、设计模式的几种原则 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress-starter/java/design/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#四、设计模式关系" class="router-link-active router-link-exact-active sidebar-item" aria-label="四、设计模式关系"><!--[--><!--]--> 四、设计模式关系 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress-starter/java/design/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#五、设计模式感想" class="router-link-active router-link-exact-active sidebar-item" aria-label="五、设计模式感想"><!--[--><!--]--> 五、设计模式感想 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress-starter/java/design/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#六、设计模式回顾" class="router-link-active router-link-exact-active sidebar-item" aria-label="六、设计模式回顾"><!--[--><!--]--> 六、设计模式回顾 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="java设计模式" tabindex="-1"><a class="header-anchor" href="#java设计模式" aria-hidden="true">#</a> Java设计模式</h1><h2 id="一、什么是设计模式" tabindex="-1"><a class="header-anchor" href="#一、什么是设计模式" aria-hidden="true">#</a> <strong>一、什么是设计模式</strong></h2><p>设计模式（Design pattern） 是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。我们使用设计模式最终的目的是实现代码的高内聚和低耦合。</p><h2 id="二、设计模式的三大分类及关键点" tabindex="-1"><a class="header-anchor" href="#二、设计模式的三大分类及关键点" aria-hidden="true">#</a> 二、设计模式的三大分类及关键点</h2><p><img src="https://xqhuang.oss-cn-beijing.aliyuncs.com/study/IMG_19AD0DA3F1CA-1.jpeg?versionId=CAEQERiBgMCMhrbc0xciIGQ3YjNlYjU3NmIyZjQyZjM5NzYyM2NlNmZmNGMwZWVl" alt="image"></p><h3 id="_1、创建型模式" tabindex="-1"><a class="header-anchor" href="#_1、创建型模式" aria-hidden="true">#</a> 1、创建型模式</h3><p>对象实例化的模式，创建型模式用于解耦对象的实例化过程。</p><ol><li><a href="/vuepress-starter/java/design/build/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html" class="">单例模式</a>：某个类智能有一个实例，提供一个全局的访问点。</li><li><a href="/vuepress-starter/java/design/build/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html" class="">工厂模式</a>：一个工厂类根据传入的参量决定创建出哪一种产品类的实例。</li><li><a href="/vuepress-starter/java/design/build/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html" class="">抽象工厂模式</a>：创建相关或依赖对象的家族，而无需明确指定具体类。</li><li><a href="/vuepress-starter/java/design/build/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html" class="">建造者模式</a>：封装一个复杂对象的创建过程，并可以按步骤构造。</li><li><a href="/vuepress-starter/java/design/build/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html" class="">原型模式</a>：通过复制现有的实例来创建新的实例。</li></ol><h3 id="_2、结构型模式" tabindex="-1"><a class="header-anchor" href="#_2、结构型模式" aria-hidden="true">#</a> 2、结构型模式</h3><p>把类或对象结合在一起形成一个更大的结构。</p><ol><li><a href="/vuepress-starter/java/design/structure/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.html" class="">装饰器模式</a>：动态的给对象添加新的功能。</li><li><a href="/vuepress-starter/java/design/structure/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html" class="">代理模式</a>：为其它对象提供一个代理以便控制这个对象的访问。</li><li><a href="/vuepress-starter/java/design/structure/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.html" class="">桥接模式</a>：将抽象部分和它的实现部分分离，使它们都可以独立的变化。</li><li><a href="/vuepress-starter/java/design/structure/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html" class="">适配器模式</a>：将一个类的方法接口转换成客户希望的另一个接口。</li><li><a href="/vuepress-starter/java/design/structure/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.html" class="">组合模式</a>：将对象组合成树形结构以表示“部分-整体”的层次结构。</li><li><a href="/vuepress-starter/java/design/structure/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.html" class="">外观模式</a>：对外提供一个统一的方法，来访问子系统中的一群接口。</li><li><a href="/vuepress-starter/java/design/structure/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html" class="">享元模式</a>：通过共享技术来有效的支持大量细粒度的对象。</li></ol><h3 id="_3、行为型模式" tabindex="-1"><a class="header-anchor" href="#_3、行为型模式" aria-hidden="true">#</a> 3、行为型模式</h3><p>类和对象如何交互，及划分责任和算法。</p><ol><li><a href="/vuepress-starter/java/design/action/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html" class="">策略模式</a>：定义一系列算法，把他们封装起来，并且使它们可以相互替换。</li><li><a href="/vuepress-starter/java/design/action/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F.html" class="">模板模式</a>：定义一个算法结构，而将一些步骤延迟到子类实现。</li><li><a href="/vuepress-starter/java/design/action/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html" class="">命令模式</a>：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。</li><li><a href="/vuepress-starter/java/design/action/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.html" class="">迭代器模式</a>：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。</li><li><a href="/vuepress-starter/java/design/action/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html" class="">观察者模式</a>：对象间的一对多的依赖关系。</li><li><a href="/vuepress-starter/java/design/action/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.html" class="">中介者模式</a>：用一个中介对象来封装一系列的对象交互。</li><li><a href="/vuepress-starter/java/design/action/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.html" class="">备忘录模式</a>：在不破坏封装的前提下，保持对象的内部状态。</li><li><a href="/vuepress-starter/java/design/action/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.html" class="">解释器模式</a>：给定一个语言，定义它的文法的一种表示，并定义一个解释器。</li><li><a href="/vuepress-starter/java/design/action/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html" class="">状态模式</a>：允许一个对象在其对象内部状态改变时改变它的行为。</li><li><a href="/vuepress-starter/java/design/action/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.html" class="">责任链模式</a>：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。</li><li><a href="/vuepress-starter/java/design/action/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html" class="">访问者模式</a>：不改变数据结构的前提下，增加作用于一组对象元素的新功能。</li></ol><h2 id="三、设计模式的几种原则" tabindex="-1"><a class="header-anchor" href="#三、设计模式的几种原则" aria-hidden="true">#</a> 三、设计模式的几种原则</h2><h4 id="_1、单一职责原则" tabindex="-1"><a class="header-anchor" href="#_1、单一职责原则" aria-hidden="true">#</a> 1、单一职责原则</h4><p>对于一个类，只有一个引起该类变化的原因；该类的职责是唯一的，且这个职责是唯一引起其他类变化的原因。</p><h4 id="_2、接口隔离原则" tabindex="-1"><a class="header-anchor" href="#_2、接口隔离原则" aria-hidden="true">#</a> 2、接口隔离原则</h4><p>客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。</p><h4 id="_3、依赖倒转原则" tabindex="-1"><a class="header-anchor" href="#_3、依赖倒转原则" aria-hidden="true">#</a> 3、依赖倒转原则</h4><p>依赖倒转原则是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><h4 id="_4、里式代换原则" tabindex="-1"><a class="header-anchor" href="#_4、里式代换原则" aria-hidden="true">#</a> 4、里式代换原则</h4><p>任何基类可以出现的地方，子类一定可以出现。里氏代换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受影响时，基类才能真正的被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><h4 id="_5、开闭原则" tabindex="-1"><a class="header-anchor" href="#_5、开闭原则" aria-hidden="true">#</a> 5、开闭原则</h4><p>（1）对于扩展是开放的（Open for extension）。这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。</p><p>（2）对于修改是关闭的（Closed for modification）。对模块行为进行扩展时，不必改动模块的源代码或者二进制代码。模块的二进制可执行版本，无论是可链接的库、DLL或者.EXE文件，都无需改动。</p><h4 id="_6、迪米特法则" tabindex="-1"><a class="header-anchor" href="#_6、迪米特法则" aria-hidden="true">#</a> 6、迪米特法则</h4><p>迪米特法则又叫做最少知识原则，就是说一个对象应当对其它对象又尽可能少的了解，不和陌生人说话。</p><h4 id="_7、合成复用原则" tabindex="-1"><a class="header-anchor" href="#_7、合成复用原则" aria-hidden="true">#</a> 7、合成复用原则</h4><p>合成复用原则要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p><h2 id="四、设计模式关系" tabindex="-1"><a class="header-anchor" href="#四、设计模式关系" aria-hidden="true">#</a> 四、设计模式关系</h2><h2 id="五、设计模式感想" tabindex="-1"><a class="header-anchor" href="#五、设计模式感想" aria-hidden="true">#</a> 五、设计模式感想</h2><p>一共有23种设计模式，可以说都是为了提高代码的可读性、可扩展性、可复用性、类的可替换性、组件化、可移植性等等特性。通过接口、抽象类、继承、实现、委托、抽象、面向接口编程、多态、重载、重写等方式使得代码的这些特性得以彰显，可以说只有深刻的理解了这些概念背后的哲学思想才能更好的理解设计模式。在设计模式中有很多思想，比如可以使用委托的不要使用继承、开闭原则，面向扩展开放，面向修改关闭，里式代换原则，父类一定能被子类代替并使用，反置则不然，面向接口编程，功能层次和实现层次分离（桥接模式）、高内聚低耦合等思想，这些思想都是宝贵的，正是因为这样的思想的存在才使得代码的更新换代的时候能够尽可能少的甚至不用修改之前的代码，直接加入新的内容。提高软件的开发周期，便于维护和升级，便于查找和纠错，易于扩展和使用。</p><p>同样的设计模式主要分为三大类，创建型、行为型、结构型。我们可以简单的这样分类，只不过这样的分类似乎并不准确，不能一语道出所有的本质，设计模式是相互关联的，有的设计模式内部其实是使用了别的设计模式作为支撑的，但是大体上这样的一种划分便于我们去记忆，仅此而已。</p><h2 id="六、设计模式回顾" tabindex="-1"><a class="header-anchor" href="#六、设计模式回顾" aria-hidden="true">#</a> 六、设计模式回顾</h2><p>从迭代器开始，我们将类中数据结构的遍历和类的功能实现分离出来，本质上使用了工厂模式；</p><p>其次我们学习了适配器模式，它将不同的接口进行适配，从而便于版本的兼容性以及其他功能；</p><p>然后我们学习了模板方法，使用模板面向抽象编程，便于新的子类的实现和管理；</p><p>之后学习了工厂模式，其实借用了模板模式来创建产品，是一种非常重要用处很广的一种方法；</p><p>然后我们学习了单例模式，有懒汉式、饿汉式等，生成关于某个类全局唯一的对象，注意多线程的影响；</p><p>之后是原型模式，用来复制复杂的对象，使用了clone方法，然后是builder模式，用一个新的类对已有的抽象接口进行整合和编程，从而构建出我们想要的东西；</p><p>然后是抽象工厂模式，使用了工厂模式，组合模式等模式，面向抽象编程，将抽象零件组装成抽象产品，便于具体工厂的创建，提高了代码的组件化和复用性；</p><p>然后是桥接模式，将类的功能层次和实现层次分割开来，便于对应的扩展和使用；</p><p>然后是策略模式，可以整体的替换策略，使用也很广泛；然后是组合模式，保证了同根同源，通过委托添加自己构成递归，树形结构，将具有树形特点的对象组合起来；</p><p>然后是装饰器模式，和组合模式的结构类似，同样是递归结构，从而可以不断的装饰，增加新的功能，很好用；</p><p>接着是visitor访问者模式，通过在类外访问类中的数据结构从而得到想要的结果，便于程序的可扩展性和组件化；</p><p>接着是责任链模式，推卸责任，根据问题的大小来考虑自己释放处理，本质是链表，便于职责分明；</p><p>然后是外观模式，通过整合各个类之间的调用关系，组建成了统一的接口(API)，便于外部类的调用；</p><p>接着是仲裁者模式，将很多类之间互相关联的关系交给仲裁者处理，省去了各个类之间的嵌套和调动，有利于高内聚和低耦合，思路清晰，便于扩展；</p><p>然后是观察者模式，通过互相委托从而能够在被观察的类发生改变的时候得到相应的改变的信息并且处理；</p><p>然后是备忘录模式，通过在某一时刻的状态保存下来，便于恢复，在游戏中使用的比较多；</p><p>然后是状态模式，将状态当做类，从而职责分明，解除了很多繁琐的if和else这些分支逻辑，便于扩展；</p><p>然后是享元模式，轻量级对象，通过共用不变对象来实现；</p><p>然后是代理模式，懒加载真正的服务器，加快访问速度，代理是帮助服务器代理的；</p><p>然后是命令模式，将命令当做类，通过保存一些列命令，从而能够随时执行这些命令，需要清除命令的本质就是一些操作和数据；</p><p>最后是解释器模式，利用编程原理的方法，来更高层次的封装代码，将自己开发的java代码当做编译系统，从而不用改变java代码只修改更高语言层次的代码就能实现不同的功能。</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: huangxiangquan@163.com">huangxiangquan</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/vuepress-starter/assets/app-999de8cb.js" defer></script>
  </body>
</html>
