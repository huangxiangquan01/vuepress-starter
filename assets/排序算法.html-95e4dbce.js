import{_ as n,o as s,c as a,a as t}from"./app-999de8cb.js";const p={},e=t(`<h1 id="排序算法" tabindex="-1"><a class="header-anchor" href="#排序算法" aria-hidden="true">#</a> 排序算法</h1><h2 id="_1-排序算法介绍" tabindex="-1"><a class="header-anchor" href="#_1-排序算法介绍" aria-hidden="true">#</a> 1. 排序算法介绍</h2><h3 id="_1-1、排序算法的简介" tabindex="-1"><a class="header-anchor" href="#_1-1、排序算法的简介" aria-hidden="true">#</a> 1.1、排序算法的简介</h3><ul><li>排序也称排序算法(Sort Algorithm)， 排序是将一组数据， 依指定的顺序进行排列的过程。</li></ul><h3 id="_1-2、排序算法的分类" tabindex="-1"><a class="header-anchor" href="#_1-2、排序算法的分类" aria-hidden="true">#</a> 1.2、排序算法的分类</h3><ul><li><strong>内部排序</strong>：指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。</li><li><strong>外部排序法</strong>：数据量过大， 无法全部加载到内存中， 需要借助外部存储(文件等)进行排序。</li></ul><h2 id="_2、算法的复杂度" tabindex="-1"><a class="header-anchor" href="#_2、算法的复杂度" aria-hidden="true">#</a> 2、算法的复杂度</h2><h3 id="_2-1、时间复杂度的度量方法" tabindex="-1"><a class="header-anchor" href="#_2-1、时间复杂度的度量方法" aria-hidden="true">#</a> 2.1、时间复杂度的度量方法</h3><ul><li><p>事后统计的方法：这种方法可行, 但是有两个问题：</p><ul><li><p>一是要想对设计的算法的运行性能进行评测， 需要实际运行该程序；</p></li><li><p>二是所得时间的统计量依赖于计算机的硬件、 软件等环境因素, 这种方式， 要在同一台计算机的相同状态下运行， 才能比较哪个算法速度更快。</p></li></ul></li><li><p>事前估算的方法：通过分析某个算法的时间复杂度来判断哪个算法更优。</p></li></ul><h3 id="_2-2、时间频度" tabindex="-1"><a class="header-anchor" href="#_2-2、时间频度" aria-hidden="true">#</a> 2.2、时间频度</h3><ul><li><p>基本介绍时间频度： 一个算法花费的时间与算法中语句的执行次数成正比例， 哪个算法中语句执行次数多， 它花费时间就多。 一个算法中的语句执行次数称为语句频度或时间频度。 记为 T(n)。 [举例说明]</p></li><li><p>举例说明-基本案例：比如计算 1-100 所有数字之和，我们设计两种算法：</p></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>int total = 0; int end = 100
//使用for循环
for(int i = 1; i &lt; end; i++){
  total += i;
}
// T(n) = n + 1
  
total = (1 + end) * end / 2;
// T(n) = 1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>举例说明-忽略常数项：</p><ul><li>2n+20 和 2n 随着 n 变大， 执行曲线无限接近, 20 可以忽略</li><li>3n+10 和 3n 随着 n 变大， 执行曲线无限接近, 10 可以忽略</li></ul></li><li><p>举例说明-忽略低次项</p><ul><li><p>2n<sup>2</sup>+3n+10 和 2n<sup>2</sup> 随着 n 变大, 执行曲线无限接近, 可以忽略 3n+10</p></li><li><p>n<sup>2</sup>+5n+20 和 n<sup>2</sup> 随着 n 变大,执行曲线无限接近, 可以忽略 5n+20</p></li></ul></li></ul><h3 id="_2-3、时间复杂度" tabindex="-1"><a class="header-anchor" href="#_2-3、时间复杂度" aria-hidden="true">#</a> 2.3、时间复杂度</h3><ul><li>一般情况下， 算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数， 用 T(n)表示， 若有某个辅助函数 f(n)， 使得当 n 趋近于无穷大时， T(n) / f(n) 的极限值为不等于零的常数， 则称 f(n)是 T(n)的同数量级函数。记作 T(n)=Ｏ ( f(n) )， 称Ｏ ( f(n) ) 为算法的渐进时间复杂度， 简称时间复杂度。</li><li>T(n) 不同， 但时间复杂度可能相同。 如： T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的 T(n) 不同， 但时间复杂度相同， 都为 O(n²)。</li><li>计算时间复杂度的方法： <ul><li><p>用常数 1 代替运行时间中的所有加法常数 T(n)=n²+7n+6 =&gt; T(n)=n²+7n+1</p></li><li><p>修改后的运行次数函数中， 只保留最高阶项 T(n)=n²+7n+1 =&gt; T(n) = n²</p></li><li><p>去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</p></li></ul></li></ul><h2 id="_2-4、常见的时间复杂度" tabindex="-1"><a class="header-anchor" href="#_2-4、常见的时间复杂度" aria-hidden="true">#</a> 2.4、常见的时间复杂度</h2><h3 id="_2-4-1、常见时间复杂度概述" tabindex="-1"><a class="header-anchor" href="#_2-4-1、常见时间复杂度概述" aria-hidden="true">#</a> 2.4.1、常见时间复杂度概述</h3><ul><li>常见时间复杂度 <ul><li>常数阶 O(1)</li><li>对数阶 O(log<sub>2</sub>n)</li><li>线性阶 O(n)</li><li>线性对数阶 O(nlog<sub>2</sub>n)</li><li>平方阶 O(n<sup>2</sup>)</li><li>立方阶 O(n<sup>3</sup>)</li><li>k 次方阶 O(n<sup>k</sup>)</li><li>指数阶 O(2<sup>n</sup>)</li></ul></li><li>结论： <ul><li>常见的算法时间复杂度由小到大依次为： Ο (1)＜Ο (log<sub>2</sub>n)＜Ο (n)＜Ο (nlog<sub>2</sub>n)＜Ο (n<sup>2</sup>)＜Ο (n<sup>3</sup>)＜ Ο (n<sup>k</sup>) ＜ Ο (2<sup>n</sup>) ， 随着问题规模 n 的不断增大， 上述时间复杂度不断增大， 算法的执行效率越低。</li><li>从图中可见， 我们应该尽可能避免使用指数阶的算法。</li></ul></li></ul><h2 id="_2-4-2、常数阶-o-1" tabindex="-1"><a class="header-anchor" href="#_2-4-2、常数阶-o-1" aria-hidden="true">#</a> 2.4.2、常数阶 O(1)</h2><ul><li><p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)</p></li><li><p>代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度</p></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>int i = 0;
int j = 0;
i++;
j++;
int m = i + j;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-4-3、对数阶-o-log2n" tabindex="-1"><a class="header-anchor" href="#_2-4-3、对数阶-o-log2n" aria-hidden="true">#</a> 2.4.3、对数阶 O(log2n)</h2><ul><li>说明：在while循环里，每次都将i乘以2，乘完之后，i距离n就越来约近。假设循环x次之后，i就大于2了，此时就退出循环了，也就是说2的x次方等于n，那么x=log<sub>2</sub>n也就是说当循环log<sub>2</sub>n次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log<sub>2</sub>n)。O(log<sub>2</sub>n)的这个2时间上是根据代码变化的，i=i*3, 则是O(log<sub>3</sub>n)。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	i <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-4-4、线性阶-o-n" tabindex="-1"><a class="header-anchor" href="#_2-4-4、线性阶-o-n" aria-hidden="true">#</a> 2.4.4、线性阶 O(n)</h3><ul><li><strong>说明</strong>：这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
  	j<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-4-5、线性对数阶-o-nlogn" tabindex="-1"><a class="header-anchor" href="#_2-4-5、线性对数阶-o-nlogn" aria-hidden="true">#</a> 2.4.5、线性对数阶 O(nlogN)</h3><ul><li><strong>说明</strong>：线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  m <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> m<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      i <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-4-6、平方阶-o-n2" tabindex="-1"><a class="header-anchor" href="#_2-4-6、平方阶-o-n2" aria-hidden="true">#</a> 2.4.6、平方阶 O(n²)</h3><ul><li><strong>说明</strong>：平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n<em>n)，即 O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m</em>n)</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">int</span> x <span class="token operator">=</span> i<span class="token punctuation">;</span>
      	x<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-4-7、其他阶" tabindex="-1"><a class="header-anchor" href="#_2-4-7、其他阶" aria-hidden="true">#</a> 2.4.7、其他阶</h4><ul><li><p>立方阶 O(n³)、 K 次方阶 O(n<sup>k</sup>)</p></li><li><p>说明： 参考上面的 O(n²) 去理解就好了， O(n³)相当于三层 n 循环， 其它的类似</p></li></ul><h2 id="_2-5、平均和最坏时间复杂度" tabindex="-1"><a class="header-anchor" href="#_2-5、平均和最坏时间复杂度" aria-hidden="true">#</a> 2.5、平均和最坏时间复杂度</h2><ul><li>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下， 该算法的运行时间。</li><li>最坏情况下的时间复杂度称最坏时间复杂度。 一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是： 最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限， 这就保证了算法的运行时间不会比最坏情况更长。</li><li>平均时间复杂度和最坏时间复杂度是否一致， 和算法有关(如图)。</li></ul><table><thead><tr><th style="text-align:center;">排序法</th><th style="text-align:center;">平均时间</th><th style="text-align:center;">最差情况</th><th style="text-align:center;">稳定度</th><th style="text-align:center;">额外空间</th><th style="text-align:center;">备注·</th></tr></thead><tbody><tr><td style="text-align:center;">冒泡</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">稳定</td><td style="text-align:center;">O(1)</td><td style="text-align:center;">n小时较好</td></tr><tr><td style="text-align:center;">交换</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">不稳定</td><td style="text-align:center;">O(1)</td><td style="text-align:center;">n小时较好</td></tr><tr><td style="text-align:center;">选择</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">不稳定</td><td style="text-align:center;">O(1)</td><td style="text-align:center;">n小时较好</td></tr><tr><td style="text-align:center;">插入</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">稳定</td><td style="text-align:center;">O(1)</td><td style="text-align:center;">大部分已排序时较好</td></tr><tr><td style="text-align:center;">基数</td><td style="text-align:center;">O(log<sub>R</sub>B)</td><td style="text-align:center;">O(log<sub>R</sub>B)</td><td style="text-align:center;">稳定</td><td style="text-align:center;">O(n)</td><td style="text-align:center;">B是真数(1-9) R是基数(个十百)</td></tr><tr><td style="text-align:center;">Shell</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">O(n<sup>s</sup>) 1&lt;s&lt;2</td><td style="text-align:center;">不稳定</td><td style="text-align:center;">O(1)</td><td style="text-align:center;">s是所选分组</td></tr><tr><td style="text-align:center;">快速</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">不稳定</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">n大时较好</td></tr><tr><td style="text-align:center;">归并</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">稳定</td><td style="text-align:center;">O(1)</td><td style="text-align:center;">n大时较好</td></tr><tr><td style="text-align:center;">堆</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">不稳定</td><td style="text-align:center;">O(1)</td><td style="text-align:center;">n大时较好</td></tr></tbody></table><h2 id="_2-6、算法的空间复杂度" tabindex="-1"><a class="header-anchor" href="#_2-6、算法的空间复杂度" aria-hidden="true">#</a> 2.6、算法的空间复杂度</h2><ul><li>类似于时间复杂度的讨论， 一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间， 它也是问题规模 n 的函数。</li><li>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。 有的算法需要占用的临时工作单元数与解决问题的规模 n 有关， 它随着 n 的增大而增大， 当 n 较大时， 将占用较多的存储单元， 例如快速排序和归并排序算法, 基数排序就属于这种情况</li><li>在做算法分析时， 主要讨论的是时间复杂度。 从用户使用体验上看， 更看重的程序执行的速度。 一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间</li></ul><h2 id="_3、冒泡排序" tabindex="-1"><a class="header-anchor" href="#_3、冒泡排序" aria-hidden="true">#</a> 3、冒泡排序</h2><h3 id="_3-1、基本介绍" tabindex="-1"><a class="header-anchor" href="#_3-1、基本介绍" aria-hidden="true">#</a> 3.1、基本介绍</h3><ul><li><p>冒泡排序（Bubble Sorting） 的基本思想是： 通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值， 若发现逆序则交换， 使值较大的元素逐渐从前移向后部， 就象水底下的气泡一样逐渐向上冒。</p></li><li><p>优化：因为排序的过程中， 各元素不断接近自己的位置， 如果一趟比较下来没有进行过交换， 就说明序列有序， 因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。 从而减少不必要的比较。 (这里说的优化， 可以在冒泡排序写好后， 再进行)</p></li></ul><h3 id="_3-2、代码实现" tabindex="-1"><a class="header-anchor" href="#_3-2、代码实现" aria-hidden="true">#</a> 3.2、代码实现</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token comment">// 测试一下冒泡排序的速度O(n^2), 给80000个数据，测试</span>
    	<span class="token comment">// 创建要给80000个的随机的数组</span>
    	<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">80000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">80000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    		arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">8000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 生成一个[0, 8000000) 数</span>
    	<span class="token punctuation">}</span>
    
    	<span class="token class-name">Date</span> date1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token class-name">SimpleDateFormat</span> simpleDateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token class-name">String</span> date1Str <span class="token operator">=</span> simpleDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;排序前的时间是=&quot;</span> <span class="token operator">+</span> date1Str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    	<span class="token comment">// 测试冒泡排序</span>
    	<span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    	<span class="token class-name">Date</span> date2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token class-name">String</span> date2Str <span class="token operator">=</span> simpleDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;排序后的时间是=&quot;</span> <span class="token operator">+</span> date2Str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 将前面额冒泡排序算法，封装成一个方法</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token comment">// 冒泡排序 的时间复杂度 O(n^2), 自己写出</span>
    	<span class="token keyword">int</span> temp<span class="token punctuation">;</span> <span class="token comment">// 临时变量</span>
    	<span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 标识变量，表示是否进行过交换</span>
    	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    			<span class="token comment">// 如果前面的数比后面的数大，则交换</span>
    			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    				flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    				temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    				arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    				arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    			<span class="token punctuation">}</span>
    		<span class="token punctuation">}</span>
    		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 在一趟排序中，一次交换都没有发生过</span>
    			<span class="token keyword">break</span><span class="token punctuation">;</span>
    		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    			flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 重置flag!!!, 进行下次判断</span>
    		<span class="token punctuation">}</span>
    	<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4、选择排序" tabindex="-1"><a class="header-anchor" href="#_4、选择排序" aria-hidden="true">#</a> 4、选择排序</h2><h3 id="_4-1、选择排序基本介绍" tabindex="-1"><a class="header-anchor" href="#_4-1、选择排序基本介绍" aria-hidden="true">#</a> 4.1、选择排序基本介绍</h3><ul><li>选择式排序也属于内部排序法， 是从欲排序的数据中， 按指定的规则选出某一元素， 再依规定交换位置后达到排序的目的。</li></ul><h3 id="_4-2、选择排序思想" tabindex="-1"><a class="header-anchor" href="#_4-2、选择排序思想" aria-hidden="true">#</a> 4.2、选择排序思想</h3><ul><li>选择排序（select sorting） 也是一种简单的排序方法。 它的基本思想是（n 是数组大小）： <ul><li>第一次从 arr[0]~arr[n-1]中选取最小值，与 arr[0] 交换;</li><li>第二次从 arr[1]~arr[n-1]中选取最小值， 与 arr[1] 交换;</li><li>第三次从 arr[2]~arr[n-1]中选取最小值， 与 arr[2] 交换， …;</li><li>第 i 次从 arr[i-1]~arr[n-1]中选取最小值， 与 arr[i-1] 交换， …;</li><li>第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值，与 arr[n-2] 交换;</li><li>总共通过 n-1 次， 得到一个按排序码从小到大排列的有序序列。</li></ul></li></ul><h3 id="_4-3、代码实现" tabindex="-1"><a class="header-anchor" href="#_4-3、代码实现" aria-hidden="true">#</a> 4.3、代码实现</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//选择排序</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelectSort</span> <span class="token punctuation">{</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">119</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">selectSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 选择排序</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 选择排序时间复杂度是 O(n^2)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>
      <span class="token keyword">int</span> min <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 说明假定的最小值，并不是最小</span>
          min <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 重置min</span>
          minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 重置minIndex</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 将最小值，放在arr[0], 即交换</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>minIndex <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-4、总结" tabindex="-1"><a class="header-anchor" href="#_4-4、总结" aria-hidden="true">#</a> 4.4、总结</h3><ul><li>由于选择排序算法在最内层的 for 循环中，满足 <code>if (min &gt; arr[j]) {</code> 条件后，只需要记录最小值和最小值在数组中的索引，无需像冒泡排序那样每次都要执行交换操作，所以选择排序算法的执行速度比冒泡排序算法快一些。</li></ul><h2 id="_5、插入排序" tabindex="-1"><a class="header-anchor" href="#_5、插入排序" aria-hidden="true">#</a> 5、插入排序</h2><h3 id="_5-1、插入排序基本介绍" tabindex="-1"><a class="header-anchor" href="#_5-1、插入排序基本介绍" aria-hidden="true">#</a> 5.1、插入排序基本介绍</h3><ul><li>插入式排序属于内部排序法， 是对于欲排序的元素以插入的方式找寻该元素的适当位置， 以达到排序的目的。</li></ul><h3 id="_5-2、插入排序思想" tabindex="-1"><a class="header-anchor" href="#_5-2、插入排序思想" aria-hidden="true">#</a> 5.2、插入排序思想</h3><ul><li>插入排序（Insertion Sorting） 的基本思想是： 把 n 个待排序的元素看成为一个有序表和一个无序表。</li><li>开始时有序表中只包含一个元素， 无序表中包含有 n-1 个元素， 排序过程中每次从无序表中取出第一个元素， 把它的排序码依次与有序表元素的排序码进行比较， 将它插入到有序表中的适当位置， 使之成为新的有序表。</li></ul><h3 id="_5-3、代码实现" tabindex="-1"><a class="header-anchor" href="#_5-3、代码实现" aria-hidden="true">#</a> 5.3、代码实现</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsertSort</span> <span class="token punctuation">{</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        
		<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">119</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token function">insertSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

	<span class="token comment">// 插入排序</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">int</span> insertVal<span class="token punctuation">;</span>
		<span class="token keyword">int</span> insertIndex<span class="token punctuation">;</span>
    
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">//定义待插入的数</span>
			insertVal <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			insertIndex <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 即arr[1]的前面这个数的下标</span>
	
			<span class="token comment">// 给insertVal 找到插入的位置</span>
			<span class="token comment">// 说明</span>
			<span class="token comment">// 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界</span>
			<span class="token comment">// 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置</span>
			<span class="token comment">// 3. 就需要将 arr[insertIndex] 后移</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>insertIndex <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> insertVal <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>insertIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				arr<span class="token punctuation">[</span>insertIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>insertIndex<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// arr[insertIndex]</span>
				insertIndex<span class="token operator">--</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 当退出while循环时，说明插入的位置找到, insertIndex + 1</span>
			<span class="token comment">// 因为我们找到的元素，即下标为 insertIndex 的元素值比 insertVal 小</span>
             <span class="token comment">// 所以我们要将 insertVal 插入到 insertIndex + 1 的位置</span>
			arr<span class="token punctuation">[</span>insertIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> insertVal<span class="token punctuation">;</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-4、总结" tabindex="-1"><a class="header-anchor" href="#_5-4、总结" aria-hidden="true">#</a> 5.4、总结</h3><ul><li>插入排序在寻找插入位置时，需要对数组元素进行整体挪位，所以效率比选择排序稍低</li></ul><h2 id="_6、希尔排序" tabindex="-1"><a class="header-anchor" href="#_6、希尔排序" aria-hidden="true">#</a> 6、希尔排序</h2><h3 id="_6-1、简单插入排序问题" tabindex="-1"><a class="header-anchor" href="#_6-1、简单插入排序问题" aria-hidden="true">#</a> 6.1、简单插入排序问题</h3><ul><li>我们看简单的插入排序可能存在的问题，数组 arr = { 2, 3, 4, 5, 6, 1 } 这时需要插入的数 1(最小)，简单插入排序的过程如下</li><li>结论: 当需要插入的数是较小的数时， 后移的次数明显增多， 对效率有影响</li></ul><h3 id="_6-2、希尔排序基本介绍" tabindex="-1"><a class="header-anchor" href="#_6-2、希尔排序基本介绍" aria-hidden="true">#</a> 6.2、希尔排序基本介绍</h3><ul><li>希尔排序是希尔（Donald Shell） 于 1959 年提出的一种排序算法。 <strong>希尔排序也是一种插入排序， 它是简单插入排序经过改进之后的一个更高效的版本， 也称为缩小增量排序。</strong></li></ul><h3 id="_6-3、希尔排序基本思想" tabindex="-1"><a class="header-anchor" href="#_6-3、希尔排序基本思想" aria-hidden="true">#</a> 6.3、希尔排序基本思想</h3><ul><li><strong>希尔排序按照增量将数组进行分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止</strong></li></ul><h3 id="_6-4、代码实现" tabindex="-1"><a class="header-anchor" href="#_6-4、代码实现" aria-hidden="true">#</a> 6.4、代码实现</h3><ul><li>理解基于交换法的希尔排序</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShellSort</span> <span class="token punctuation">{</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token function">shellSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 希尔排序时， 对有序序列在插入时采用交换法,</span>
	<span class="token comment">// 思路(算法) ===&gt; 代码</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">int</span> temp<span class="token punctuation">;</span>
		<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token comment">// 根据前面的逐步分析，使用循环处理</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">// 遍历各组中所有的元素(共gap组，每组有？个元素), 步长gap</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> gap<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">-=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
						temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
						arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>
						arr<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>      
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>编写基于插入法的希尔排序算法</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShellSort</span> <span class="token punctuation">{</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

		<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
		
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;排序前&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token function">shellSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;排序前&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 对交换式的希尔排序进行优化-&gt;移位法</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 增量gap, 并逐步得缩小增量</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">// 从第gap个元素，逐个对其所在的组进行直接插入排序</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
				<span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> gap <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> temp <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
						<span class="token comment">// 移动</span>
						arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>
						j <span class="token operator">-=</span> gap<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token comment">// temp 比 arr[j - gap] 大，所以需要插入在 j 的位置</span>
					arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_7、快速排序" tabindex="-1"><a class="header-anchor" href="#_7、快速排序" aria-hidden="true">#</a> 7、快速排序</h2><h3 id="_7-1、快排简介" tabindex="-1"><a class="header-anchor" href="#_7-1、快排简介" aria-hidden="true">#</a> 7.1、快排简介</h3><ol><li>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</li><li>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</li><li>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</li><li>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。</li><li>虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</li><li>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</li></ol><h3 id="_7-2、代码思路" tabindex="-1"><a class="header-anchor" href="#_7-2、代码思路" aria-hidden="true">#</a> 7.2、代码思路</h3><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。</li><li>在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><h3 id="_7-3、代码实现" tabindex="-1"><a class="header-anchor" href="#_7-3、代码实现" aria-hidden="true">#</a> 7.3、代码实现</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token punctuation">{</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
		
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;排序前&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;排序前&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">int</span> partitionIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> partitionIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> partitionIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token comment">//终止while循环以后left和right一定相等的</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token operator">--</span>right<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
          <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token operator">++</span>left<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>
      <span class="token comment">//right可以改为left</span>
      <span class="token keyword">return</span> left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_8、归并排序" tabindex="-1"><a class="header-anchor" href="#_8、归并排序" aria-hidden="true">#</a> 8、归并排序</h2><h3 id="_8-1、归并排序基本介绍" tabindex="-1"><a class="header-anchor" href="#_8-1、归并排序基本介绍" aria-hidden="true">#</a> 8.1、归并排序基本介绍</h3><ul><li>归并排序（MERGE-SORT） 是利用归并的思想实现的排序方法， 该算法采用经典的分治（divide-and-conquer）策略</li><li><strong>分治法将问题分(divide)成一些小的问题然后递归求解， 而治(conquer)的阶段则将分的阶段得到的各答案&quot;修补&quot;在一起， 即分而治之</strong></li></ul><h3 id="_8-2、归并排序思想" tabindex="-1"><a class="header-anchor" href="#_8-2、归并排序思想" aria-hidden="true">#</a> 8.2、归并排序思想</h3><ul><li>分 --&gt; 治</li></ul><h3 id="_8-3、归并排序代码思路" tabindex="-1"><a class="header-anchor" href="#_8-3、归并排序代码思路" aria-hidden="true">#</a> 8.3、归并排序代码思路</h3><ul><li><p>合并时，其实是拿着原数组（arr）中两个相邻的子数组（arr1、arr2）进行合并，我们使用三个指针，来表示两个子数组在原数组中的位置</p><ul><li>arr[left] ~ arr[mid] 为 arr1</li><li>arr[mid + 1] ~ arr[right] 为 arr2</li></ul></li><li><p>如何合并？</p><ul><li>首先，需要一个临时的 temp 数组，其大小与原数组 arr 一样</li><li>定义辅助指针 i 遍历 arr1 ，定义辅助指针 j 遍历 arr2 ，原则就是，把 arr1 和 arr2 中的数往 temp 中放，使得 temp[left] ~ temp[right] 是有序数组</li><li>最后把 temp 临时数组中的数据拷贝回原数组中（个人认为，最后一下次再拷贝回去就行。。。）</li></ul></li><li><p>如何分？</p><ul><li>向左递归拆分：mergeSort(arr, left, mid, temp);</li><li>向右递归拆分：mergeSort(arr, mid + 1, right, temp);</li></ul></li></ul><h3 id="_8-4、代码实现" tabindex="-1"><a class="header-anchor" href="#_8-4、代码实现" aria-hidden="true">#</a> 8.4、代码实现</h3><h4 id="_8-4-1、编写归并排序算法" tabindex="-1"><a class="header-anchor" href="#_8-4-1、编写归并排序算法" aria-hidden="true">#</a> 8.4.1、编写归并排序算法</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergetSort</span> <span class="token punctuation">{</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        
		<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 归并排序需要一个额外空间</span>
		<span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;归并排序后=&quot;</span> <span class="token operator">+</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">}</span>

	<span class="token comment">// 分+合方法</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 中间索引</span>
			<span class="token comment">// 向左递归进行分解</span>
			<span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// 向右递归进行分解</span>
			<span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// 合并</span>
			<span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 合并的方法</span>
	<span class="token doc-comment comment">/**
	 * 
	 * <span class="token keyword">@param</span> <span class="token parameter">arr</span>   排序的原始数组
	 * <span class="token keyword">@param</span> <span class="token parameter">left</span>  左边有序序列的初始索引
	 * <span class="token keyword">@param</span> <span class="token parameter">mid</span>   中间索引
	 * <span class="token keyword">@param</span> <span class="token parameter">right</span> 右边索引
	 * <span class="token keyword">@param</span> <span class="token parameter">temp</span>  做中转的数组
	 */</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>

		<span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> <span class="token comment">// 初始化i, 左边有序序列的初始索引</span>
		<span class="token keyword">int</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 初始化j, 右边有序序列的初始索引</span>
		<span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 指向temp数组的当前索引</span>

		<span class="token comment">// (一)</span>
		<span class="token comment">// 先把左右两边(有序)的数据按照规则填充到temp数组</span>
		<span class="token comment">// 直到左右两边的有序序列，有一边处理完毕为止</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 继续</span>
			<span class="token comment">// 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span>
			<span class="token comment">// 即将左边的当前元素，填充到 temp数组</span>
			<span class="token comment">// 然后 t++, i++</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				temp<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
				t <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
				i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 反之,将右边有序序列的当前元素，填充到temp数组</span>
				temp<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
				t <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
				j <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// (二)</span>
		<span class="token comment">// 把有剩余数据的一边的数据依次全部填充到temp</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 左边的有序序列还有剩余的元素，就全部填充到temp</span>
			temp<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			t <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 右边的有序序列还有剩余的元素，就全部填充到temp</span>
			temp<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
			t <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			j <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// (三)</span>
		<span class="token comment">// 将temp数组的元素拷贝到arr</span>
		<span class="token comment">// 注意，并不是每次都拷贝所有</span>
		t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> tempLeft <span class="token operator">=</span> left<span class="token punctuation">;</span> <span class="token comment">//</span>
		<span class="token comment">// 第一次合并 tempLeft = 0 , right = 1 //第二次： tempLeft = 2 right = 3 //第三次： tL=0 ri=3</span>
		<span class="token comment">// 最后一次 tempLeft = 0 right = 7</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>tempLeft <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			arr<span class="token punctuation">[</span>tempLeft<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>
			t <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			tempLeft <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_9、基数排序" tabindex="-1"><a class="header-anchor" href="#_9、基数排序" aria-hidden="true">#</a> 9、基数排序</h2><h3 id="_9-1、基数排序基本介绍" tabindex="-1"><a class="header-anchor" href="#_9-1、基数排序基本介绍" aria-hidden="true">#</a> 9.1、基数排序基本介绍</h3><ul><li>基数排序（radix sort） 属于“分配式排序” （distribution sort） ， 又称“桶子法” （bucket sort） 或 bin sort， 顾名思义， 它是通过键值的各个位的值， 将要排序的元素分配至某些“桶” 中， 达到排序的作用</li><li>基数排序法是属于稳定性的排序， 基数排序法的是效率高的稳定性排序法</li><li>基数排序(Radix Sort)是桶排序的扩展</li><li>基数排序是 1887 年赫尔曼· 何乐礼发明的。 它是这样实现的： 将整数按位数切割成不同的数字， 然后按每个位数分别比较。</li></ul><h3 id="_9-2、基数排序思想" tabindex="-1"><a class="header-anchor" href="#_9-2、基数排序思想" aria-hidden="true">#</a> 9.2、基数排序思想</h3><ul><li>将所有待比较数值统一为同样的数位长度， 数位较短的数前面补零。</li><li>然后， <strong>从最低位开始， 依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</strong></li></ul><h3 id="_9-3、基数排序图解" tabindex="-1"><a class="header-anchor" href="#_9-3、基数排序图解" aria-hidden="true">#</a> 9.3、基数排序图解</h3><ul><li><p>有 10 个桶，对应编号为 0~9</p></li><li><p>步骤</p><ul><li>第一步：根据原数组 arr 中每个元素的个位数，将其依次放入 0~9 号桶中（每个桶从前往后放），放置完毕后，再将桶中的数据依次取出（每个桶从前往后取），放回原数组 arr 中，这样原数组 arr 中个位数的元素就已经按照顺序排好了</li><li>第二步：根据原数组 arr 中每个元素的十位数，将其依次放入 0~9 号桶中（每个桶从前往后放），放置完毕后，再将桶中的数据依次取出（每个桶从前往后取），放回原数组 arr 中，这样原数组 arr 中十位数 + 个位数的元素就已经按照顺序排好了</li><li>第三步：根据原数组 arr 中每个元素的百位数，将其依次放入 0~9 号桶中（每个桶从前往后放），放置完毕后，再将桶中的数据依次取出（每个桶从前往后取），放回原数组 arr 中，这样原数组 arr 中百位数 + 十位数 + 个位数的元素就已经按照顺序排好了</li><li>…</li></ul></li><li><p>何时排序完毕？当数组中最长位数的元素处理完毕，排序完成</p></li><li><p>桶的容量如何确定？假设数组每个元素位数相同，那么单个桶最大容量即为数组容量，我们用一个二维数组来表示桶：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>	<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>我们如何知道每桶中装了几个元素？这也需要记录，用一个一维数组来记录：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>	<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucketElementCounts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>总结：</p><ul><li><p>假设数组中元素的最长位数为 maxLength ，则处理完 maxLength 位数后，数组排序完毕：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>使用一个 for 循环处理原一维数组 arr ，将其放入桶中</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul></li><li><p>使用两层 for 循环，处理 10 个 桶，将其中的元素放回原一维数组中</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> bucketElementCounts<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>bucketElementCounts<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> bucketElementCounts<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_9-4、代码实现" tabindex="-1"><a class="header-anchor" href="#_9-4、代码实现" aria-hidden="true">#</a> 9.4、代码实现</h3><h4 id="_9-4-1、理解基数排序" tabindex="-1"><a class="header-anchor" href="#_9-4-1、理解基数排序" aria-hidden="true">#</a> 9.4.1、理解基数排序</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RadixSort</span> <span class="token punctuation">{</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		
		<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">53</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">542</span><span class="token punctuation">,</span> <span class="token number">748</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">214</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token function">radixSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;基数排序后 &quot;</span> <span class="token operator">+</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token punctuation">}</span>

	<span class="token comment">//基数排序方法</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		
		<span class="token comment">//根据前面的推导过程，我们可以得到最终的基数排序代码</span>
		
		<span class="token comment">//1. 得到数组中最大的数的位数</span>
		<span class="token keyword">int</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//假设第一个数就是最大数</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				max <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		
		<span class="token comment">//定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span>
		<span class="token comment">//说明</span>
		<span class="token comment">//1. 二维数组包含10个一维数组</span>
		<span class="token comment">//2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span>
		<span class="token comment">//3. 名明确，基数排序是使用空间换时间的经典算法</span>
		<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
		
		<span class="token comment">//为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span>
		<span class="token comment">//可以这里理解</span>
		<span class="token comment">//比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span>
		<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucketElementCounts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		
		
		<span class="token comment">//第1轮(针对每个元素的个位进行排序处理)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//取出每个元素的个位的值</span>
            <span class="token keyword">int</span> digitOfElement <span class="token operator">=</span> i <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>
            <span class="token comment">//放入到对应的桶中</span>
            bucket<span class="token punctuation">[</span>digitOfElement<span class="token punctuation">]</span><span class="token punctuation">[</span>bucketElementCounts<span class="token punctuation">[</span>digitOfElement<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
            bucketElementCounts<span class="token punctuation">[</span>digitOfElement<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
		<span class="token comment">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span>
		<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token comment">//遍历每一桶，并将桶中是数据，放入到原数组</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> bucketElementCounts<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">//如果桶中，有数据，我们才放入到原数组</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>bucketElementCounts<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">//循环该桶即第k个桶(即第k个一维数组), 放入</span>
				<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> bucketElementCounts<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token comment">//取出元素放入到arr</span>
					arr<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//第l轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span>
			bucketElementCounts<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;第1轮，对个位的排序处理 arr =&quot;</span> <span class="token operator">+</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
		
		<span class="token comment">//第2轮(针对每个元素的十位进行排序处理)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 取出每个元素的十位的值</span>
            <span class="token keyword">int</span> digitOfElement <span class="token operator">=</span> i <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//748 / 10 =&gt; 74 % 10 =&gt; 4</span>
            <span class="token comment">// 放入到对应的桶中</span>
            bucket<span class="token punctuation">[</span>digitOfElement<span class="token punctuation">]</span><span class="token punctuation">[</span>bucketElementCounts<span class="token punctuation">[</span>digitOfElement<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
            bucketElementCounts<span class="token punctuation">[</span>digitOfElement<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
		<span class="token comment">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span>
		index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token comment">// 遍历每一桶，并将桶中是数据，放入到原数组</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> bucketElementCounts<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">// 如果桶中，有数据，我们才放入到原数组</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>bucketElementCounts<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">// 循环该桶即第k个桶(即第k个一维数组), 放入</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> bucketElementCounts<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token comment">// 取出元素放入到arr</span>
					arr<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//第2轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span>
			bucketElementCounts<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;第2轮，对个位的排序处理 arr =&quot;</span> <span class="token operator">+</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		
		<span class="token comment">//第3轮(针对每个元素的百位进行排序处理)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 取出每个元素的百位的值</span>
            <span class="token keyword">int</span> digitOfElement <span class="token operator">=</span> i <span class="token operator">/</span> <span class="token number">100</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 748 / 100 =&gt; 7 % 10 = 7</span>
            <span class="token comment">// 放入到对应的桶中</span>
            bucket<span class="token punctuation">[</span>digitOfElement<span class="token punctuation">]</span><span class="token punctuation">[</span>bucketElementCounts<span class="token punctuation">[</span>digitOfElement<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
            bucketElementCounts<span class="token punctuation">[</span>digitOfElement<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
		<span class="token comment">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span>
		index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token comment">// 遍历每一桶，并将桶中是数据，放入到原数组</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> bucketElementCounts<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">// 如果桶中，有数据，我们才放入到原数组</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>bucketElementCounts<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">// 循环该桶即第k个桶(即第k个一维数组), 放入</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> bucketElementCounts<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token comment">// 取出元素放入到arr</span>
					arr<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//第3轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span>
			bucketElementCounts<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;第3轮，对个位的排序处理 arr =&quot;</span> <span class="token operator">+</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>	
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-5、基数排序的说明" tabindex="-1"><a class="header-anchor" href="#_9-5、基数排序的说明" aria-hidden="true">#</a> 9.5、基数排序的说明</h3><ul><li>基数排序是对传统桶排序的扩展， 速度很快</li><li>基数排序是经典的空间换时间的方式， 占用内存很大，当对海量数据排序时， 容易造成 OutOfMemoryError 。</li><li>基数排序时稳定的。 [注：假定在待排序的记录序列中， 存在多个具有相同的关键字的记录， 若经过排序， 这些记录的相对次序保持不变， 即在原序列中， r[i]=r[j]， 且 r[i]在 r[j]之前， 而在排序后的序列中， r[i]仍在 r[j]之前，则称这种排序算法是稳定的； 否则称为不稳定的]</li><li>有负数的数组， 我们不用基数排序来进行排序, 如果要支持负数， 参考: https://code.i-harness.com/zh-CN/q/e98fa9</li></ul><h2 id="_10、常用排序算法总结和对比" tabindex="-1"><a class="header-anchor" href="#_10、常用排序算法总结和对比" aria-hidden="true">#</a> 10、常用排序算法总结和对比</h2><h3 id="_10-1、排序算法的比较图" tabindex="-1"><a class="header-anchor" href="#_10-1、排序算法的比较图" aria-hidden="true">#</a> 10.1、排序算法的比较图</h3><table><thead><tr><th style="text-align:center;">排序算法</th><th style="text-align:center;">平均时间复杂度</th><th style="text-align:center;">最好情况</th><th style="text-align:center;">最坏情况</th><th style="text-align:center;">空间复杂度</th><th style="text-align:center;">排序方式</th><th>稳定度</th></tr></thead><tbody><tr><td style="text-align:center;">冒泡排序</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">O(n)</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">O(1)</td><td style="text-align:center;">In-place</td><td>稳定</td></tr><tr><td style="text-align:center;">选择排序</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">O(1)</td><td style="text-align:center;">In-place</td><td>不稳定</td></tr><tr><td style="text-align:center;">插入排序</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">O(n)</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">O(1)</td><td style="text-align:center;">In-place</td><td>稳定</td></tr><tr><td style="text-align:center;">希尔排序</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">O(nlog<sup>2</sup>n)</td><td style="text-align:center;">O(nlog<sup>2</sup>n)</td><td style="text-align:center;">O(1)</td><td style="text-align:center;">In-place</td><td>不稳定</td></tr><tr><td style="text-align:center;">归并排序</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">O(n)</td><td style="text-align:center;">Out-place</td><td>稳定</td></tr><tr><td style="text-align:center;">快速排序</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">In-place</td><td>不稳定</td></tr><tr><td style="text-align:center;">堆排序</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">O(nlogn)</td><td style="text-align:center;">O(1)</td><td style="text-align:center;">In-place</td><td>不稳定</td></tr><tr><td style="text-align:center;">桶排序</td><td style="text-align:center;">O(n + k)</td><td style="text-align:center;">O(n + k)</td><td style="text-align:center;">O(n<sup>2</sup>)</td><td style="text-align:center;">O(n + k)</td><td style="text-align:center;">Out-place</td><td>稳定</td></tr><tr><td style="text-align:center;">基数排序</td><td style="text-align:center;">O(n * k)</td><td style="text-align:center;">O(n * k)</td><td style="text-align:center;">O(n * k)</td><td style="text-align:center;">O(n + k)</td><td style="text-align:center;">Out-place</td><td>稳定</td></tr><tr><td style="text-align:center;">计数排序</td><td style="text-align:center;">O(n + k)</td><td style="text-align:center;">O(n + k)</td><td style="text-align:center;">O(n + k)</td><td style="text-align:center;">O(k)</td><td style="text-align:center;">Out-place</td><td>稳定</td></tr></tbody></table><h3 id="_10-2、相关术语解释" tabindex="-1"><a class="header-anchor" href="#_10-2、相关术语解释" aria-hidden="true">#</a> 10.2、相关术语解释</h3><ul><li>稳定：如果 a 原本在 b 前面， 而 a=b， 排序之后 a 仍然在 b 的前面；</li><li>不稳定：如果 a 原本在 b 的前面， 而 a=b， 排序之后 a 可能会出现在 b 的后面；</li><li>内排序： 所有排序操作都在内存中完成；</li><li>外排序： 由于数据太大， 因此把数据放在磁盘中， 而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度： 一个算法执行所耗费的时间。</li><li>空间复杂度： 运行完一个程序所需内存的大小。</li><li>n: 数据规模</li><li>k: “桶” 的个数</li><li>In-place：不占用额外内存</li><li>Out-place：占用额外内存</li></ul>`,109),o=[e];function c(l,i){return s(),a("div",null,o)}const r=n(p,[["render",c],["__file","排序算法.html.vue"]]);export{r as default};
