import{_ as o,o as i,c as e,a as r}from"./app-999de8cb.js";const a={},n=r('<h1 id="任务性质类型" tabindex="-1"><a class="header-anchor" href="#任务性质类型" aria-hidden="true">#</a> 任务性质类型</h1><h3 id="cpu密集型-cpu-bound" tabindex="-1"><a class="header-anchor" href="#cpu密集型-cpu-bound" aria-hidden="true">#</a> CPU密集型（CPU-bound）</h3><p>​ CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。</p><p>​ 在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下 的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。</p><p>​ CPU bound的程序一般般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I/O设备，也可能是因为程序是多线程实现因此 屏蔽掉了等待I/O的时间。</p><p>​ 线程数一般设置为：</p><blockquote><p>线程数 = CPU核数 + 1 (现代CPU支持超线程)</p></blockquote><h3 id="io密集型-i-o-bound" tabindex="-1"><a class="header-anchor" href="#io密集型-i-o-bound" aria-hidden="true">#</a> IO密集型（I/O bound）</h3><p>​ IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操 作，此时CPU Loading并不高。</p><p>​ I/O bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而pipeline做得不是很 好，没有充分利用处理器能力。</p><p>​ 线程数一般设置为：</p><blockquote><p>线程数 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目 CPU密集型 vs IO密集型</p></blockquote><h3 id="cpu密集型-vs-io密集型" tabindex="-1"><a class="header-anchor" href="#cpu密集型-vs-io密集型" aria-hidden="true">#</a> CPU密集型 vs IO密集型</h3><p>​ 计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这 种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效 地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p><p>​ 计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集 型任务。对于计算密集型任务，最好用C语言编写。</p><p>​ 第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间 都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常 见的大部分任务都是IO密集型任务，比如Web应用。</p><p>​ IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速 度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首 选，C语言最差。\\</p><h1 id="fork-join-框架" tabindex="-1"><a class="header-anchor" href="#fork-join-框架" aria-hidden="true">#</a> Fork/Join 框架</h1><p>​ Fork/Join 框架是 Java7 提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后 得到大任务结果的框架。</p><p>Fork/Join特性：</p><ol><li>ForkJoinPool 不是为了替代 ExecutorService，而是它的补充，在某些应用场景下性能比 ExecutorService 更好。（见 Java Tip: When to use ForkJoinPool vs ExecutorService ）</li><li>ForkJoinPool 主要用于实现“分而治之”的算法，特别是分治之后递归调用的函数，例如 quick sort 等。</li><li>ForkJoinPool 最适合的是计算密集型的任务，如果存在 I/O，线程间同步，sleep() 等会造成线程长时间阻塞的情况时，最好配 合使用 ManagedBlocker。</li></ol><h1 id="工作窃取算法" tabindex="-1"><a class="header-anchor" href="#工作窃取算法" aria-hidden="true">#</a> 工作窃取算法</h1><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。</p><p>​ 我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别 放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。 但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干 活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程 之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务 执行。</p><p>​ 工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里 只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p><ol><li>ForkJoinPool 的每个工作线程都维护着一个工作队列（WorkQueue），这是一个双端队列（Deque），里面存放的对象是任务 （ForkJoinTask）。</li><li>每个工作线程在运行中产生新的任务（通常是因为调用了 fork()）时，会放入工作队列的队尾，并且工作线程在处理自己的工作 队列时，使用的是 LIFO 方式，也就是说每次从队尾取出任务来执行。</li><li>每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线 程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。</li><li>在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。 5. 在既没有自己的任务，也没有可以窃取的任务时，进入休眠。</li></ol><h1 id="fork-join的使用" tabindex="-1"><a class="header-anchor" href="#fork-join的使用" aria-hidden="true">#</a> Fork/Join的使用</h1><h3 id="forkjointask" tabindex="-1"><a class="header-anchor" href="#forkjointask" aria-hidden="true">#</a> ForkJoinTask</h3><p>​ 使用 ForkJoin 框架，必须首先创建一个 ForkJoin 任务。它提供在任务中执行 fork() 和 join() 操作的机制，通常情况下我们不需要直接继承 ForkJoinTask 类，而只需要继承它的子类，Fork/Join 框架提供了以下两个子类：</p><ul><li>RecursiveAction：用于没有返回结果的任务。(比如写数据到磁盘，然后就退出了。 一个RecursiveAction可以把自己的工作分割成更小的几块， 这样它们可以由独立的线程或者CPU执行。 通过继承来实现一个RecursiveAction)</li><li>RecursiveTask ：用于有返回结果的任务。(可以将自己的工作分割为若干更小任务，并将这些子任务的执行合并到一个集体结果。 可以有几个水平的分割和合并)</li><li>CountedCompleter： 在任务完成执行后会触发执行一个自定义的钩子函数</li><li>ForkJoinPool ：ForkJoinTask 需要通过 ForkJoinPool 来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</li></ul>',30),d=[n];function l(c,t){return i(),e("div",null,d)}const p=o(a,[["render",l],["__file","Future_ForkJoin.html.vue"]]);export{p as default};
