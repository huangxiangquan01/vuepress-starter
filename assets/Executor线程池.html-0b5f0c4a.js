import{_ as n,o as e,c as a,a as s}from"./app-999de8cb.js";const i={},t=s(`<h1 id="executor线程池" tabindex="-1"><a class="header-anchor" href="#executor线程池" aria-hidden="true">#</a> Executor线程池</h1><h2 id="线程" tabindex="-1"><a class="header-anchor" href="#线程" aria-hidden="true">#</a> 线程</h2><p>​ 线程是调度CPU资源的最小单位，线程模型分为KLT模型与ULT模型，JVM使用的KLT模型，Java线程与OS线程保持1:1的映射关系，也就是说有一个java线程也会在操作系统里有一个对应的线程。Java线程有多种生命状态</p><ul><li>NEW 新建</li><li>RUNNABLE 运行</li><li>BLOCKED 阻塞</li><li>WAITING 等待</li><li>TIMED_WAITING 超时等待</li><li>TERMINATED 终结</li></ul><h4 id="协程" tabindex="-1"><a class="header-anchor" href="#协程" aria-hidden="true">#</a> 协程</h4><pre><code>	协程 (纤程，用户级线程)，目的是为了追求最大力度的发挥硬件性能和提升软件的速 度，协程基本原理是:在某个点挂起当前的任务，并且保存栈信息，去执行另一个任 务；等完成或达到某个条件时，再还原原来的栈信息并继续执行(整个过程线程不需要 上下文切换)。
</code></pre><blockquote><p>Java原生不支持协程，在纯java代码里需要使用协程的话需要引入第三方包,如：quasar</p></blockquote><h4 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h4><pre><code>	“线程池”，顾名思义就是一个线程缓存，线程是稀缺资源，如果被无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此Java中提供线程池对线程进行统一分配、 调优和监控
</code></pre><h3 id="线程池介绍" tabindex="-1"><a class="header-anchor" href="#线程池介绍" aria-hidden="true">#</a> 线程池介绍</h3><p>​ 如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁 线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线 ​ 程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</p><ul><li>单个任务处理时间比较短</li><li>需要处理的任务数量很大</li><li>线程池优势重用存在的线程，减少线程创建，消亡的开销，提高性能</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="线程的实现方式" tabindex="-1"><a class="header-anchor" href="#线程的实现方式" aria-hidden="true">#</a> 线程的实现方式</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token comment">//  实现Runnable接口的类将被Thread执行，表示一个基本的任务</span>
    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
        <span class="token comment">// run方法就是它所有的内容，就是实际执行的任务 </span>
        <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
     <span class="token punctuation">}</span> 
     <span class="token comment">//  Callable同样是任务，与Runnable接口的区别在于它接收泛型，同时它执行 任务后带有返回内容 </span>
     <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> 
        <span class="token comment">// 相对于run方法的带有返回值的call方法 </span>
        <span class="token class-name">V</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="executor框架" tabindex="-1"><a class="header-anchor" href="#executor框架" aria-hidden="true">#</a> Executor框架</h3><p>Executor下有一个重要子接口ExecutorService，其中定义了线程池的具体 行为:</p><ol><li>execute（Runnable command）：履行Ruannable类型的任务,</li><li>submit（task）：可用来提交Callable或Runnable任务，并返回代表此任务的Future 对象</li><li>shutdown（）：在完成已提交的任务后封闭办事，不再接管新任务,</li><li>shutdownNow（）：停止所有正在履行的任务并封闭办事。</li><li>isTerminated（）：测试是否所有任务都履行完毕了。</li><li>isShutdown（）：测试是否该ExecutorService已被关闭。</li></ol><h3 id="线程池重点属性" tabindex="-1"><a class="header-anchor" href="#线程池重点属性" aria-hidden="true">#</a> 线程池重点属性</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutor</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExecutorService</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token constant">RUNNING</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">COUNT_BITS</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">SIZE</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token comment">// 29</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CAPACITY</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//  (00001111 11111111 11111111 11111111)</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ ctl 是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两 部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，这里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存 workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常 量表示workerCount的上限值，大约是5亿。</p><h3 id="ctl相关方法" tabindex="-1"><a class="header-anchor" href="#ctl相关方法" aria-hidden="true">#</a> ctl相关方法</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutor</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExecutorService</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token constant">CAPACITY</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token constant">CAPACITY</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>runStateOf：获取运行状态；</li><li>workerCountOf：获取活动线程数；</li><li>ctlOf：获取运行状态和活动线程数的值。</li></ul><h3 id="线程池存在5种状态" tabindex="-1"><a class="header-anchor" href="#线程池存在5种状态" aria-hidden="true">#</a> 线程池存在5种状态</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>     <span class="token comment">// runState is stored in the high-order bits</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">RUNNING</span> <span class="token operator">=</span> ‐<span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span> <span class="token comment">// 高3位为111  (11100000 00000000 00000000 00000000)</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span> <span class="token comment">//高3位为000   (00000000 00000000 00000000 00000000)</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">STOP</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span> <span class="token comment">//高3位为001       (00100000 00000000 00000000 00000000)</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TIDYING</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span> <span class="token comment">//高3位为010    (01000000 00000000 00000000 00000000)</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TERMINATED</span> <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span> <span class="token comment">//高3位为011 (01100000 00000000 00000000 00000000)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>1、RUNNING</p><blockquote><p>状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行 处理。 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处 于RUNNING状态，并且线程池中的任务数为0！</p></blockquote><p>2、SHUTDOWN</p><blockquote><p>状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p></blockquote><p>3、STOP</p><blockquote><p>状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中 断正在处理的任务。 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p></blockquote><p>4、TIDYING</p><blockquote><p>状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING 状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在 ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理； 可以通过重载terminated()函数来实现。 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也 为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的 任务为空时，就会由STOP -&gt; TIDYING。</p></blockquote><p>5、TERMINATED</p><blockquote><p>状态说明：线程池彻底终止，就变成TERMINATED状态。 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING - &gt; TERMINATED。</p></blockquote></blockquote><p>进入TERMINATED的条件如下：</p><ul><li>线程池不是RUNNING状态；</li><li>线程池状态不是TIDYING状态或TERMINATED状态；</li><li>如果线程池状态是SHUTDOWN并且workerQueue为空；</li><li>workerCount为0；</li><li>设置TIDYING状态成功。</li></ul><h3 id="线程池的具体实现" tabindex="-1"><a class="header-anchor" href="#线程池的具体实现" aria-hidden="true">#</a> 线程池的具体实现</h3><ul><li>ThreadPoolExecutor 默认线程池</li><li>ScheduledThreadPoolExecutor 定时线程池</li></ul><h1 id="threadpoolexecutor" tabindex="-1"><a class="header-anchor" href="#threadpoolexecutor" aria-hidden="true">#</a> ThreadPoolExecutor</h1><h3 id="线程池的创建" tabindex="-1"><a class="header-anchor" href="#线程池的创建" aria-hidden="true">#</a> 线程池的创建</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    public ThreadPoolExecutor(int corePoolSize,
                                  int maximumPoolSize,
                                  long keepAliveTime,
                                  TimeUnit unit,
                                  BlockingQueue&lt;Runnable&gt; workQueue,
                                  ThreadFactory threadFactory,
                                  RejectedExecutionHandler handler) {}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="任务提交" tabindex="-1"><a class="header-anchor" href="#任务提交" aria-hidden="true">#</a> 任务提交</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    //提交任务无返回值
    public void execute() 

    //任务执行完成后有返回值
    public Future&lt;?&gt; submit() 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="参数解释" tabindex="-1"><a class="header-anchor" href="#参数解释" aria-hidden="true">#</a> 参数解释</h3><h4 id="corepoolsize" tabindex="-1"><a class="header-anchor" href="#corepoolsize" aria-hidden="true">#</a> corePoolSize</h4><p>​ 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当 前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到 阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p><h4 id="maximumpoolsize" tabindex="-1"><a class="header-anchor" href="#maximumpoolsize" aria-hidden="true">#</a> maximumPoolSize</h4><p>​ 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；</p><h4 id="keepalivetime" tabindex="-1"><a class="header-anchor" href="#keepalivetime" aria-hidden="true">#</a> keepAliveTime</h4><p>​ 线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时 候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待 的时间超过了keepAliveTime；</p><h4 id="unit" tabindex="-1"><a class="header-anchor" href="#unit" aria-hidden="true">#</a> unit</h4><p>​ keepAliveTime的单位；</p><h4 id="workqueue" tabindex="-1"><a class="header-anchor" href="#workqueue" aria-hidden="true">#</a> workQueue</h4><p>​ 用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列：</p><ul><li>ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；</li><li>LinkedBlockingQueue：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；</li><li>SynchronousQueue：一个不存储元素的阻塞队列，每个插入操作必须等到 另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQuene；</li><li>priorityBlockingQueue：具有优先级的无界阻塞队列；</li></ul><h4 id="threadfactory" tabindex="-1"><a class="header-anchor" href="#threadfactory" aria-hidden="true">#</a> threadFactory</h4><p>​ 它是ThreadFactory类型的变量，用来创建新线程。默认使用 Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程 时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设 置了线程的名称。</p><h4 id="handler" tabindex="-1"><a class="header-anchor" href="#handler" aria-hidden="true">#</a> handler</h4><p>​ 线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必 须采取一种策略处理该任务，线程池提供了4种策略：</p><ul><li>AbortPolicy：直接抛出异常，默认策略；</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li><li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li>DiscardPolicy：直接丢弃任务；</li></ul><p>上面的4种策略都是ThreadPoolExecutor的内部类。</p><p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如 记录日志或持久化存储不能处理的任务。</p><h3 id="线程池监控" tabindex="-1"><a class="header-anchor" href="#线程池监控" aria-hidden="true">#</a> 线程池监控</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>   <span class="token doc-comment comment">/**
   * 
   /
   public long getTaskCount() //线程池已执行与未执行的任务总数 
   public long getCompletedTaskCount() //已完成的任务数
   public int getPoolSize() //线程池当前的线程数 
   public int getActiveCount() //线程池中正在执行任务的线程数量
</span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="scheduledthreadpoolexecutor" tabindex="-1"><a class="header-anchor" href="#scheduledthreadpoolexecutor" aria-hidden="true">#</a> ScheduledThreadPoolExecutor</h1><p>它用来处理延时任务或定时任务。 它接收ScheduledFutureTask类型的任务，是线程池调度任务的最小单位，有三种提交任务 的方式：</p><ul><li>schedule</li><li>scheduledAtFixedRate</li><li>scheduledWithFixedDelay</li></ul><p>它采用DelayQueue存储等待的任务</p><ul><li>DelayQueue内部封装了一个PriorityQueue，它会根据time的先后时间排序，若 time相同则根据sequenceNumber排序；</li><li>DelayQueue也是一个无界队列；</li></ul><h3 id="scheduledfuturetask" tabindex="-1"><a class="header-anchor" href="#scheduledfuturetask" aria-hidden="true">#</a> ScheduledFutureTask</h3><p>ScheduledFutureTask接收的参数(成员变量)：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    private long time：// 任务开始的时间 
    private final long sequenceNumber; //任务的序号 
    private final long period：// 任务执行的时间间隔
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>工作线程的执行过程：</p><ul><li><p>工作线程会从DelayQueue取已经到期的任务去执行；</p></li><li><p>执行结束后重新设置任务的到期时间，再次放回DelayQueue</p><p>ScheduledThreadPoolExecutor会把待执行的任务放到工作队列DelayQueue中， DelayQueue封装了一个PriorityQueue，PriorityQueue会对队列中的 ScheduledFutureTask进行排序，具体的排序算法实现如下：</p></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    public int compareTo(Delayed other) { 
         if (other == this) // compare zero if same object 
            return 0; 
         if (other instanceof ScheduledFutureTask) { 
              ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other; 
              long diff = time ‐ x.time; 
              if (diff &lt; 0) 
                  return ‐1; 
              else if (diff &gt; 0) 
              return 1;
         else if (sequenceNumber &lt; x.sequenceNumber) 
             return ‐1; 
         else 
             return 1;
         } 
         long diff = getDelay(NANOSECONDS) ‐ other.getDelay(NANOSECONDS); 
             return (diff &lt; 0) ? ‐1 : (diff &gt; 0) ? 1 : 0; 
         }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><pre><code>&gt; 1. 首先按照time排序，time小的排在前面，time大的排在后面； 
&gt; 1. 如果time相同，按照sequenceNumber排序，sequenceNumber小的排在前 面，sequenceNumber大的排在后面，换句话说，如果两个task的执行时间相同， 优先执行先提交的task。
</code></pre><h3 id="scheduledfuturetask之run方法实现" tabindex="-1"><a class="header-anchor" href="#scheduledfuturetask之run方法实现" aria-hidden="true">#</a> ScheduledFutureTask之run方法实现</h3><p>run方法是调度task的核心，task的执行实际上是run方法的执行。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>        <span class="token doc-comment comment">/**
         * Overrides FutureTask version so as to reset/requeue if periodic.
         */</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">boolean</span> periodic <span class="token operator">=</span> <span class="token function">isPeriodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//如果当前线程池已经不支持执行任务，则取消</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">canRunInCurrentRunState</span><span class="token punctuation">(</span>periodic<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//如果不需要周期性执行，则直接执行run方法然后结束</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>periodic<span class="token punctuation">)</span>
                <span class="token class-name">ScheduledFutureTask</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//如果需要周期执行，则在执行完任务以后，设置下一次执行时间</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ScheduledFutureTask</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">runAndReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 计算下次执行该任务的时间</span>
                <span class="token function">setNextRunTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//重复执行任务</span>
                <span class="token function">reExecutePeriodic</span><span class="token punctuation">(</span>outerTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><pre><code>1. 如果当前线程池运行状态不可以执行任务，取消该任务，然后直接返回，否则执行 步骤
2. 如果不是周期性任务，调用FutureTask中的run方法执行，会设置执行结果，然后 直接返回，否则执行步骤3； 
3. 如果是周期性任务，调用FutureTask中的runAndReset方法执行，不会设置执行 结果，然后直接返回，否则执行步骤4和步骤5； 
4. 计算下次执行该任务的具体时间； 
5. 重复执行任务。
</code></pre><h3 id="reexecuteperiodic方法" tabindex="-1"><a class="header-anchor" href="#reexecuteperiodic方法" aria-hidden="true">#</a> reExecutePeriodic方法</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    /**
     * Requeues a periodic task unless current run state precludes it.
     * Same idea as delayedExecute except drops task rather than rejecting.
     *
     * @param task the task
     */
    void reExecutePeriodic(RunnableScheduledFuture&lt;?&gt; task) {
        if (canRunInCurrentRunState(true)) {
            super.getQueue().add(task);
            if (!canRunInCurrentRunState(true) &amp;&amp; remove(task))
                task.cancel(false);
            else
                ensurePrestart();
        }
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该方法和delayedExecute方法类似，不同的是：</p><ol><li>由于调用reExecutePeriodic方法时已经执行过一次周期性任务了，所以不会 reject当前任务；</li><li>传入的任务一定是周期性任务</li></ol><h3 id="线程池任务的提交" tabindex="-1"><a class="header-anchor" href="#线程池任务的提交" aria-hidden="true">#</a> 线程池任务的提交</h3><p>首先是schedule方法，该方法是指任务在指定延迟时间到达后触发，只会执行一次。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public ScheduledFuture&lt;?&gt; schedule(Runnable command,
                                       long delay,
                                       TimeUnit unit) {
        if (command == null || unit == null)
            throw new NullPointerException();

        //这里是一个嵌套结构，首先把用户提交的任务包装成ScheduledFutureTask 
        //然后在调用decorateTask进行包装，该方法是留给用户去扩展的，默认是个 空方法
        RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,
            new ScheduledFutureTask&lt;Void&gt;(command, null,
                                         triggerTime(delay, unit)));

        //包装好任务以后，就进行提交了
        delayedExecute(t);
        return t;
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>任务提交方法：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    private void delayedExecute(RunnableScheduledFuture&lt;?&gt; task) {
        //如果线程池已经关闭，则使用拒绝策略把提交任务拒绝掉
        if (isShutdown())
            reject(task);
        else {
            //与ThreadPoolExecutor不同，这里直接把任务加入延迟队列
            super.getQueue().add(task);

             //如果当前状态无法执行任务，则取消
            if (isShutdown() &amp;&amp;
                !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;
                remove(task))
                task.cancel(false);
            else
                //这里是增加一个worker线程，避免提交的任务没有worker去执行 
                //原因就是该类没有像ThreadPoolExecutor一样，woker满了才放入队列
                ensurePrestart();
        }
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="delayedworkqueue" tabindex="-1"><a class="header-anchor" href="#delayedworkqueue" aria-hidden="true">#</a> DelayedWorkQueue</h3><p>​ ScheduledThreadPoolExecutor之所以要自己实现阻塞的工作队列，是因为 ScheduledThreadPoolExecutor要求的工作队列有些特殊。</p><p>​ DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和 PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以 DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近 的任务在队列的前面（注意：这里的顺序并不是绝对的，堆中的排序只保证了子节点的下次 执行时间要比父节点的下次执行时间要大，而叶子节点之间并不一定是顺序的）。</p><h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h1><ul><li>与Timer执行定时任务的比较，相比Timer，ScheduedThreadPoolExecutor有 什么优点；</li><li>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，所以它也是一 个线程池，也有coorPoolSize和workQueue，ScheduledThreadPoolExecutor特 殊的地方在于，自己实现了优先工作队列DelayedWorkQueue；</li><li>ScheduledThreadPoolExecutor实现了ScheduledExecutorService，所以就有 了任务调度的方法，如schedule，scheduleAtFixedRate和 scheduleWithFixedDelay，同时注意他们之间的区别；</li><li>内部类ScheduledFutureTask继承自FutureTask，实现了任务的异步执行并且 可以获取返回结果。同时也实现了Delayed接口，可以通过getDelay方法获取将要执 行的时间间隔；</li><li>周期任务的执行其实是调用了FutureTask类中的runAndReset方法，每次执行 完不设置结果和状态。</li><li>详细分析了DelayedWorkQueue的数据结构，它是一个基于最小堆结构的优先 队列，并且每次出队时能够保证取出的任务是当前队列中下次执行时间最小的任务。 同时注意一下优先队列中堆的顺序，堆中的顺序并不是绝对的，但要保证子节点的值 要比父节点的值要大，这样就不会影响出队的顺序。</li></ul>`,86),l=[t];function c(o,r){return e(),a("div",null,l)}const u=n(i,[["render",c],["__file","Executor线程池.html.vue"]]);export{u as default};
