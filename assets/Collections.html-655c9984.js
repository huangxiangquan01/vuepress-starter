import{_ as a,o as e,c as l,a as i}from"./app-999de8cb.js";const t={},n=i(`<h1 id="集合" tabindex="-1"><a class="header-anchor" href="#集合" aria-hidden="true">#</a> 集合</h1><h2 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap" aria-hidden="true">#</a> HashMap</h2><h3 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构" aria-hidden="true">#</a> 数据结构</h3><blockquote><p>数组+链表+(红黑树jdk&gt;=8)</p></blockquote><h3 id="源码原理分析" tabindex="-1"><a class="header-anchor" href="#源码原理分析" aria-hidden="true">#</a> 源码原理分析</h3><p><strong>重要成员变量</strong></p><ul><li>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; Hash表默认初始容量</li><li>MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 最大Hash表容量</li><li>DEFAULT_LOAD_FACTOR = 0.75f；默认加载因子</li><li>TREEIFY_THRESHOLD = 8；链表转红黑树阈值</li><li>UNTREEIFY_THRESHOLD = 6；红黑树转链表阈值</li><li>MIN_TREEIFY_CAPACITY = 64；链表转红黑树时hash表最小容量阈值，达不到优先扩容。</li></ul><pre><code>HashMap是线程不安全的，不安全的具体原因就是在高并发场景下，扩容可能产生死锁 (Jdk1.7存在)以及get操作可能带来的数据丢失。
</code></pre><h3 id="jdk8-扩容" tabindex="-1"><a class="header-anchor" href="#jdk8-扩容" aria-hidden="true">#</a> Jdk8-扩容</h3><p>Java8 HashMap扩容跳过了Jdk7扩容的坑，对源码进行了优化，采用高低位拆分转移方 式，避免了链表环的产生。</p><h1 id="concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap" aria-hidden="true">#</a> ConcurrentHashMap</h1><h3 id="数据结构-1" tabindex="-1"><a class="header-anchor" href="#数据结构-1" aria-hidden="true">#</a> 数据结构</h3><p>ConcurrentHashMap的数据结构与HashMap基本类似，区别在于：</p><ol><li>内部在数据写入时加了同步机制(分段锁)保证线程安全，读操作是无锁操作；</li><li>扩容时老数据的转移 是并发执行的，这样扩容的效率更高。</li></ol><h3 id="并发安全控制" tabindex="-1"><a class="header-anchor" href="#并发安全控制" aria-hidden="true">#</a> 并发安全控制</h3><p>Java7 ConcurrentHashMap基于ReentrantLock实现分段锁.</p><p>Java8中 ConcurrentHashMap基于分段锁 + CAS保证线程安全，分段锁基于synchronized关键字实现；</p><h3 id="源码原理分析-1" tabindex="-1"><a class="header-anchor" href="#源码原理分析-1" aria-hidden="true">#</a> 源码原理分析</h3><p><strong>重要成员变量</strong>:</p><ul><li><p>LOAD_FACTOR: 负载因子, 默认75%, 当table使用率达到75%时, 为减少table的hash碰撞, tabel长度将扩容一倍。</p><blockquote><p>负载因子计算: 元素总个数 % table.lengh</p></blockquote></li><li><p>TREEIFY_THRESHOLD: 默认8, 当链表长度达到8时, 将结构转变为红黑树。</p></li><li><p>UNTREEIFY_THRESHOLD: 默认6, 红黑树转变为链表的阈值。</p></li><li><p>MIN_TRANSFER_STRIDE: 默认16, table扩容时, 每个线程最少迁移table的槽位 个数。</p></li><li><p>MOVED: 值为-1, 当Node.hash为MOVED时, 代表着table正在扩容</p></li><li><p>TREEBIN, 置为-2, 代表此元素后接红黑树。</p></li><li><p>nextTable: table迁移过程临时变量, 在迁移过程中将元素全部迁移到nextTable上。</p><blockquote><ol><li>0: table还没有被初始化</li><li>-1: table正在初始化</li><li>小于-1: 实际值为resizeStamp(n) &lt;&lt;RESIZE_STAMP_SHIFT+2, 表明table正在扩容</li><li>大于0: 初始化完成后, 代表table最大存放元素 的个数, 默认为0.75 * n</li></ol></blockquote></li><li><p>transferIndex: table容量从n扩到2n时, 是从索引n-&gt;1的元素开始迁移, transferIndex代表当前已经迁移的元素下标</p></li><li><p>ForwardingNode: 一个特殊的Node节点, 其hashcode=MOVED, 代表着此时 table正在做扩容操作。扩容期间, 若table某个元素为null, 那么该元素设置为 ForwardingNode, 当下个线程向这个元素插入数据时, 检查hashcode=MOVED, 就会帮着扩容。</p></li></ul><p>ConcurrentHashMap由三部分构成, table + 链表 + 红黑树, 其中table是一个数组, 既然是 数组, 必须要在使用时确定数组的大小, 当table存放的元素过多时, 就需要扩容, 以减少碰撞发生次数, 本文就讲解扩容的过程。扩容检查主要发生在插入元素(putVal())的过程:</p><ul><li>一个线程插完元素后, 检查table使用率, 若超过阈值, 调用transfer进行扩容</li><li>一个线程插入数据时, 发现table对应元素的hash=MOVED, 那么调用 helpTransfer()协助扩容。</li></ul><h3 id="协助扩容helptransfer" tabindex="-1"><a class="header-anchor" href="#协助扩容helptransfer" aria-hidden="true">#</a> 协助扩容helpTransfer</h3><p>主要做了如下事情:</p><ul><li>检查是否扩容完成 对sizeCtrl = sizeCtrl+1,</li><li>然后调用transfer()进行真正的扩容。</li></ul><h3 id="扩容transfer" tabindex="-1"><a class="header-anchor" href="#扩容transfer" aria-hidden="true">#</a> 扩容transfer</h3><p>扩容的整体步骤就是新建一个nextTab, size是之前的2倍, 将table上的非空元素 迁移到nextTab上面去。</p><p><strong>两个变量</strong>:</p><ul><li>advance: 表示是否可以向下一个轮元素进行迁移。</li><li>finishing: table所有元素是否迁移完成。</li></ul><p>大致做了如下事情:</p><ul><li>确定线程每轮迁移元素的个数stride, 比如进来一个线程, 确定扩容table下标为 (a,b]之间元素, 下一个线程扩容(b,c]。这里对b-a或者c-b也是由最小值16限制的。也就是说每个线程最少扩容连续16个table的元素。而标志当前迁移的下标保存在 transferIndex里面。</li><li>检查nextTab是否完成初始化, 若没有的话, 说明是第一个迁移的线程, 先初始化 nextTab, size是之前table的2倍。</li><li>进入while循环查找本轮迁移的table下标元素区间, 保存在(bound, i]中, 注意这 里是半开半闭区间。</li><li>从i -&gt; bound开始遍历table中每个元素,</li></ul><p>这里是从大到小遍历的:</p><ol><li>若该元素为空, 则向该元素标写入ForwardingNode, 然后检查下一个元素。 当别 的线程向这个元素插入数据时, 根据这个标志符知道了table正在被别的线程迁移, 在 putVal中就会调用helpTransfer帮着迁移。</li><li>若该元素的hash=MOVED, 代表次table正在处于迁移之中, 跳过。按道理不会跑 着这里的。</li><li>否则说明该元素跟着的是一个链表或者是个红黑树结构, 若hash&gt;0, 则说明是个链表, 若f instanceof TreeBin, 则说明是个红黑树结构。 <ul><li>链表迁移原理如下: 遍历链表每个节点。 若节点的f.hash&amp;n==0成立, 则将节点放在i, 否则, 则将节点放在n+i上面。</li><li>迁移前, 对该元素进行加锁。 遍历链表时, 这里使用lastRun变量, 保留的是上次hash的 值, 假如整个链表全部节点f.hash&amp;n==0, 那么第二次遍历, 只要找到lastRun的值, 那么认为之后的节点都是相同值, 减少了不必要的f.hash&amp;n取值。遍历完所有的节点后, 此时形成了两条链表, ln存放的是f.hash&amp;n=0的节点, hn存放的是非0的节点, 然后将ln存放在 nextTable第i元素的位置, n+i存放在n+i的位置。</li><li>蓝色节点代表:f.hash&amp;n==0, 绿色节点代表f.hash&amp;n!=0。 最终蓝色的节点仍在存放在(0, n)范围里, 绿的节点存放在(n, 2n-1)的范围之内。</li><li>迁移链表和红黑树的原理是一样的, 在红黑树中, 我们记录了每个红黑树的 first(这个节点不是hash最小的节点)和每个节点的next, 根据这两个元素, 我们可以访问红黑树所有的元素, 红黑树此时也是一个链表, 红黑树和链表迁移的过程一样。红黑树根据迁移后拆分成了hn和ln, 根据链表长度确定链表是红黑树结构还是退化为了链 表。</li></ul></li><li>第一个线程开始迁移时, 设置了sizeCtl= resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT+2, 此后每个新来帮助迁移的线程都会sizeCtl=sizeCtl+1, 完成迁移 后,sizeCtl-1, 那么只要有一个线程还处于迁移状态, 那么sizeCtl&gt; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT+2一直成立, 当只有最后一个线程完成迁移之后, 等式两边才成立。 可能大家会有疑问, 第一个线程并没有对sizeCtl=sizeCtl+1, 此时完成后再减一, 那不是不相等了吗, 注意这里, sizeCtl在减一前, 将值赋给了sc, 等式比较的是sc。</li></ol><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>table扩容过程就是将table元素迁移到新的table上, 在元素迁移时, 可以并发完成, 加快了迁移速度, 同时不至于阻塞线程。所有元素迁移完成后, 旧的table直接丢失, 直接使用新的 table。</p><h1 id="copyonwrite机制" tabindex="-1"><a class="header-anchor" href="#copyonwrite机制" aria-hidden="true">#</a> CopyOnWrite机制</h1><p>核心思想：读写分离，空间换时间，避免为保证并发安全导致的激烈的锁竞争。<br> 划关键点：</p><ol><li>CopyOnWrite适用于读多写少的情况，最大程度的提高读的效率；</li><li>CopyOnWrite是最终一致性，在写的过程中，原有的读的数据是不会发生更新的，只有新的读 才能读到最新数据；</li><li>如何使其他线程能够及时读到新的数据，需要使用volatile变量；</li><li>写的时候不能并发写，需要对写操作进行加锁；</li></ol>`,38),r=[n];function h(s,d){return e(),l("div",null,r)}const p=a(t,[["render",h],["__file","Collections.html.vue"]]);export{p as default};
