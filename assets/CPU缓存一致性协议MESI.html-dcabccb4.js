import{_ as t,o as e,c as l,a}from"./app-999de8cb.js";const d={},i=a('<h1 id="cpu缓存一致性协议mesi" tabindex="-1"><a class="header-anchor" href="#cpu缓存一致性协议mesi" aria-hidden="true">#</a> CPU缓存一致性协议MESI</h1><h3 id="带有高速缓存的cpu执行计算的流程" tabindex="-1"><a class="header-anchor" href="#带有高速缓存的cpu执行计算的流程" aria-hidden="true">#</a> 带有高速缓存的CPU执行计算的流程</h3><ol><li>程序以及数据被加载到主内存</li><li>指令和数据被加载到CPU的高速缓存</li><li>CPU执行指令，把结果写到高速缓存</li><li>高速缓存中的数据写回主内存</li></ol><h3 id="目前流行的多级缓存结构" tabindex="-1"><a class="header-anchor" href="#目前流行的多级缓存结构" aria-hidden="true">#</a> 目前流行的多级缓存结构</h3><p>由于CPU的运算速度超越了1级缓存的数据I\\O能力，CPU厂商又引入了多级的缓存结构。</p><h3 id="多核cpu多级缓存一致性协议mesi" tabindex="-1"><a class="header-anchor" href="#多核cpu多级缓存一致性协议mesi" aria-hidden="true">#</a> 多核CPU多级缓存一致性协议MESI</h3><p>多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致,不让系统数据混乱。这里就引出了一个 一致性的协议MESI。</p><h3 id="mesi协议缓存状态" tabindex="-1"><a class="header-anchor" href="#mesi协议缓存状态" aria-hidden="true">#</a> MESI协议缓存状态</h3><p>MESI 是指4中状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：</p><table><thead><tr><th style="text-align:left;">状态</th><th style="text-align:left;">描述</th><th style="text-align:left;">监听任务</th></tr></thead><tbody><tr><td style="text-align:left;">M 修改 (Modified)</td><td style="text-align:left;">该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</td><td style="text-align:left;">缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</td></tr><tr><td style="text-align:left;">E 独享、互斥 (Exclusive)</td><td style="text-align:left;">该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</td><td style="text-align:left;">缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</td></tr><tr><td style="text-align:left;">S 共享 (Shared)</td><td style="text-align:left;">该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</td><td style="text-align:left;">缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</td></tr><tr><td style="text-align:left;">I 无效 (Invalid)</td><td style="text-align:left;">该Cache line无效。</td><td style="text-align:left;">无</td></tr></tbody></table><blockquote><p><strong>注意</strong>: 对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的，而S状态可能是非一致的。如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。</p></blockquote><p>从上面的意义看来E状态是一种投机性的优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务。</p><h3 id="mesi状态转换" tabindex="-1"><a class="header-anchor" href="#mesi状态转换" aria-hidden="true">#</a> MESI状态转换</h3><ol><li>cache分类:</li></ol><table><thead><tr><th style="text-align:left;">触发事件</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">本地读取（Local read）</td><td style="text-align:left;">本地cache读取本地cache数据</td></tr><tr><td style="text-align:left;">本地写入（Local write）</td><td style="text-align:left;">本地cache写入本地cache数据</td></tr><tr><td style="text-align:left;">远端读取（Remote read）</td><td style="text-align:left;">其他cache读取本地cache数据</td></tr><tr><td style="text-align:left;">远端写入（Remote write）</td><td style="text-align:left;">其他cache写入本地cache数据</td></tr></tbody></table><p>2.cache分类：</p><blockquote><p>前提：</p><blockquote><ul><li>所有的cache共同缓存了主内存中的某一条数据。</li><li>本地cache:指当前cpu的cache。</li><li>触发cache:触发读写事件的cache。</li><li>其他cache:指既除了以上两种之外的cache。</li><li>注意：本地的事件触发 本地cache和触发cache为相同。</li></ul></blockquote></blockquote><table><thead><tr><th style="text-align:left;">状态</th><th style="text-align:left;">触发本地读取</th><th style="text-align:left;">触发本地写入</th><th style="text-align:left;">触发远端读取</th><th style="text-align:left;">触发远端写入</th></tr></thead><tbody><tr><td style="text-align:left;">M状态（修改）</td><td style="text-align:left;">本地cache:M  触发cache:M 其他cache: I</td><td style="text-align:left;">本地cache:M  触发cache:M 其他cache:I</td><td style="text-align:left;">本地cache:M→E→S 触发cache:I→S 其他cache:I→S 同步主内存后修改为E独享,同步触发、其他cache后本地、触发、其他cache修改为S共享</td><td style="text-align:left;">本地cache:M→E→S→I 触发cache:I→S→E→M 其他cache:I→S→I 同步和读取一样,同步完成后触发cache改为M，本地、其他cache改为I</td></tr><tr><td style="text-align:left;">E状态（独享）</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">S状态(共享)</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">I状态（无效）</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr></tbody></table><h1 id="mesi优化和他们引入的问题" tabindex="-1"><a class="header-anchor" href="#mesi优化和他们引入的问题" aria-hidden="true">#</a> MESI优化和他们引入的问题</h1><p>​ 缓存的一致性消息传递是要时间的，这就使其切换时会产生延迟。当一个缓存被切换状态时其他缓存收到消息完成各自的切换并且发出回应消息这么一长串的时间中CPU都会等待所有缓存响应完成。可能出现的阻塞都会导致各种各样的性能问题和稳定性问题。</p><h3 id="cpu切换状态阻塞解决-存储缓存-store-bufferes" tabindex="-1"><a class="header-anchor" href="#cpu切换状态阻塞解决-存储缓存-store-bufferes" aria-hidden="true">#</a> CPU切换状态阻塞解决-存储缓存（Store Bufferes）</h3><p>​ 比如你需要修改本地缓存中的一条信息，那么你必须将I（无效）状态通知到其他拥有该缓存数据的CPU缓存中，并且等待确认。等待确认的过程会阻塞处理器，这会降低处理器的性能。应为这个等待远远比一个指令的执行时间长的多。</p><h3 id="store-bufferes" tabindex="-1"><a class="header-anchor" href="#store-bufferes" aria-hidden="true">#</a> Store Bufferes</h3><p>​ 为了避免这种CPU运算能力的浪费，Store Bufferes被引入使用。处理器把它想要写入到主存的值写到缓存，然后继续去处理其他事情。当所有失效确认（Invalidate Acknowledge）都接收到时，数据才会最终被提交。</p><h3 id="store-bufferes的风险" tabindex="-1"><a class="header-anchor" href="#store-bufferes的风险" aria-hidden="true">#</a> Store Bufferes的风险</h3><ul><li>就是处理器会尝试从存储缓存（Store buffer）中读取值，但它还没有进行提交。这个的解决方案称为Store Forwarding，它使得加载的时候，如果存储缓存中存在，则进行返回。</li><li>保存什么时候会完成，这个并没有任何保证</li></ul><h3 id="硬件内存模型" tabindex="-1"><a class="header-anchor" href="#硬件内存模型" aria-hidden="true">#</a> 硬件内存模型</h3><p>​ 执行失效也不是一个简单的操作，它需要处理器去处理。另外，存储缓存（Store Buffers）并不是无穷大的，所以处理器有时需要等待失效确认的返回。这两个操作都会使得性能大幅降低。为了应付这种情况，引入了失效队列。它们的约定如下：</p><ul><li>对于所有的收到的Invalidate请求，Invalidate Acknowlege消息必须立刻发送</li><li>Invalidate并不真正执行，而是被放在一个特殊的队列中，在方便的时候才会去执行。</li><li>处理器不会发送任何消息给所处理的缓存条目，直到它处理Invalidate。 即便是这样处理器已然不知道什么时候优化是允许的，而什么时候并不允许。干脆处理器将这个任务丢给了写代码的人。这就是内存屏障（Memory Barriers）。</li></ul><blockquote><p>写屏障 Store Memory Barrier(a.k.a. ST, SMB, smp_wmb)是一条告诉处理器在执行这之后的指令之前，应用所有已经在存储缓存（store buffer）中的保存的指令。 读屏障Load Memory Barrier (a.k.a. LD, RMB, smp_rmb)是一条告诉处理器在执行任何的加载前，先应用所有已经在失效队列中的失效操作的指令。</p></blockquote>',30),r=[i];function c(h,s){return e(),l("div",null,r)}const f=t(d,[["render",c],["__file","CPU缓存一致性协议MESI.html.vue"]]);export{f as default};
